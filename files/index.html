<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8" />
  <meta name="description" content="Put Pokémon head-to-head to find out who your REAL favorite is!">
  <!-- Open Graph for richer link previews -->
  <meta property="og:title" content="PokeRankr">
  <meta property="og:description" content="Put Pokémon head-to-head to find out who your REAL favorite is!">
  <meta property="og:image" content="https://yourdomain.com/Assets/pokerankr.png">
  <meta property="og:url" content="https://yourdomain.com/">
  <meta property="og:type" content="website">
  <title>PokéRankr - Head-to-Head Pokémon Ranking!</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
  <!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="index-page">
<!-- User Header (shows when logged in) -->
 <div id="userHeader" style="display:none;">
  <style>
    #userHeader {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 10px 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      border: 2px solid #d2deff;
    }
    
    /* Mobile: Move to bottom */
    @media (max-width: 768px) {
      #userHeader {
        top: auto;
        bottom: 10px;
        right: 10px;
        left: 10px;
        max-width: fit-content;
        margin: 0 auto;
      }
    }
    
    /* Hide on non-index pages for mobile */
    @media (max-width: 768px) {
      body:not(.index-page) #userHeader {
        display: none !important;
      }
    }
  </style>
    <div style="display:flex; align-items:center; gap:12px;">
<div style="width:48px; height:48px; display:flex; align-items:center; justify-content:center; flex-shrink:0;">
  <img id="headerSprite" src="" alt="Trainer" style="max-width:64px; max-height:64px; width:auto; height:auto; image-rendering:pixelated; object-fit:contain;">
</div>
      <span id="headerUsername" style="font-weight:600; color:var(--text);"></span>
      <button id="btnLogout" class="compact" style="--button_color:#ff3b30; --button_outline_color:#ff3b30;">
        <span class="button_top" style="color:white; padding:0.3em 0.8em; font-size:12px;">Log Out</span>
      </button>
    </div>
  </div>
  <!-- ====== LOADING PAGE ====== -->
  <div id="loading-page" class="page active">
    <div class="logo">
  <img src="assets/logo.png" alt="PokéRankr Logo">
</div>
    <div class="menu-buttons">
  <div class="menu-primary">
  <button id="btnStart" class="menu-button"><span class="button_top">Start New Ranking</span></button>
  <button id="btnManageSaves" class="menu-button" style="display:none;"><span class="button_top">Continue / Manage Saves</span></button>
  <button id="btnLoginSignup" class="menu-button" style="display:none; --button_color:#34c759; --button_outline_color:#2a7f43;">
    <span class="button_top" style="color:white;">Login / Sign Up</span>
  </button>
</div>
  
  <div class="menu-secondary">
  <button onclick="window.location.href='saved.html'"><span class="button_top">Saved Rankings</span></button>
  <button onclick="window.location.href='badges.html'" id="btnBadges" style="position:relative;">
    <span class="button_top">Badges</span>
    <span id="badgeNotification" class="notification-bubble" style="display:none;"></span>
  </button>
  <button id="btnDownload" class="menu-button"><span class="button_top">Download</span></button>
  <button id="btnUpload" class="menu-button"><span class="button_top">Upload</span></button>
  <button id="btnFeedback" class="menu-button"><span class="button_top">Feedback</span></button>
  <button id="btnSettings" class="menu-button"><span class="button_top">Settings</span></button>
</button>
</div>
</div>

<!-- Keep the hidden input for uploads -->
<input type="file" id="uploadInput" accept="application/json" style="display:none" />
<!-- Welcome Modal -->
    <div id="welcomeModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1200; align-items:center; justify-content:center;">
      <div style="background:#fff; padding:24px; border-radius:12px; width:min(400px, 90%); text-align:center;">
        <div class="logo" style="width:120px; height:120px; margin:0 auto 16px;">
          <img src="assets/logo.png" alt="PokéRankr Logo" style="width:100%; height:100%; object-fit:contain;">
        </div>
        <h2 style="margin:0 0 20px; color:var(--text);">Welcome to PokéRankr!</h2>
        <div style="display:flex; flex-direction:column; gap:12px;">
          <button id="btnWelcomeLogin" class="menu-button">
            <span class="button_top">Login / Sign Up!</span>
          </button>
          <button id="btnWelcomeGuest" class="menu-button">
            <span class="button_top">Play Without Signing In</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Local Storage Warning Modal -->
    <div id="localWarningModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1200; align-items:center; justify-content:center;">
      <div style="background:#fff; padding:24px; border-radius:12px; width:min(500px, 90%);">
        <h3 style="margin:0 0 16px; color:var(--text);">⚠️ Important Notice</h3>
        <p style="margin:0 0 20px; color:var(--text-soft); line-height:1.5;">
          Playing without an account means your progress is stored locally on this device. 
          If you're in incognito mode or clear your browser data (history, cache, cookies), 
          <strong>all your progress will be lost!</strong>
        </p>
        <div style="display:flex; gap:12px; justify-content:center;">
          <button id="btnContinueLocally" class="menu-button">
            <span class="button_top">Continue Locally</span>
          </button>
          <button id="btnWarningLogin" class="menu-button">
            <span class="button_top">Login / Sign Up</span>
          </button>
        </div>
      </div>
    </div>

<!-- Login/Signup Modal -->
<div id="authModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1200; align-items:center; justify-content:center;">
  <div style="background:#fff; padding:24px; border-radius:12px; width:min(400px, 90%); position:relative;">
    <span id="authClose" aria-label="Close" style="position:absolute; top:10px; right:10px; font-size:22px; line-height:1; cursor:pointer;">×</span>
    <h3 id="authTitle" style="margin:0 0 20px; color:var(--text);">Welcome Back!</h3>
    
    <!-- Tab buttons to switch between login and signup -->
    <div style="display:flex; gap:8px; margin:0 0 20px; border-bottom:2px solid #e5e7eb;">
      <button id="tabLogin" class="auth-tab active" style="flex:1; padding:12px; background:none; border:none; border-bottom:3px solid #2563eb; font-weight:600; cursor:pointer;">
        Log In
      </button>
      <button id="tabSignup" class="auth-tab" style="flex:1; padding:12px; background:none; border:none; border-bottom:3px solid transparent; font-weight:600; cursor:pointer;">
        Sign Up
      </button>
    </div>
    
    <!-- Login Form -->
<form id="loginForm" style="display:block;">
  <label for="loginEmail" style="display:block; font-weight:600; margin:0 0 4px; color:var(--text);">Email</label>
  <input type="email" id="loginEmail" required style="width:100%; padding:10px; margin:0 0 16px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
  
  <label for="loginPassword" style="display:block; font-weight:600; margin:0 0 4px; color:var(--text);">Password</label>
  <input type="password" id="loginPassword" required style="width:100%; padding:10px; margin:0 0 8px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
  
  <div style="text-align:right; margin:0 0 16px;">
    <a href="#" id="forgotPasswordLink" style="color:#2563eb; text-decoration:none; font-size:14px;">Forgot Password?</a>
  </div>
  
  <div id="loginError" style="color:#ff3b30; margin:0 0 16px; display:none; font-size:14px;"></div>
  
  <button type="submit" class="menu-button" style="width:100%;">
    <span class="button_top">Log In</span>
  </button>
</form>

<!-- Forgot Password Form (hidden by default) -->
<form id="forgotPasswordForm" style="display:none;">
  <p style="margin:0 0 16px; color:#6b7280;">Enter your email and we'll send you a password reset link.</p>
  
  <label for="resetEmail" style="display:block; font-weight:600; margin:0 0 4px; color:var(--text);">Email</label>
  <input type="email" id="resetEmail" required style="width:100%; padding:10px; margin:0 0 16px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
  
  <div id="resetError" style="color:#ff3b30; margin:0 0 16px; display:none; font-size:14px;"></div>
  <div id="resetSuccess" style="color:#34c759; margin:0 0 16px; display:none; font-size:14px;"></div>
  
 <div class="button-row" style="display:flex; justify-content:center; gap:12px; width:100%;">
  <button type="button" id="backToLogin" class="menu-button">
    <span class="button_top" style="white-space:nowrap;">Back</span>
  </button>
  <button type="submit" class="menu-button">
    <span class="button_top" style="white-space:nowrap;">Send Reset Link</span>
  </button>
</div>

  </div>
</form>
    
    <!-- Signup Form -->
    <form id="signupForm" style="display:none;">
      <label for="signupEmail" style="display:block; font-weight:600; margin:0 0 4px; color:var(--text);">Email</label>
      <input type="email" id="signupEmail" required style="width:100%; padding:10px; margin:0 0 16px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
      
      <label for="signupPassword" style="display:block; font-weight:600; margin:0 0 4px; color:var(--text);">Password</label>
      <input type="password" id="signupPassword" required minlength="6" style="width:100%; padding:10px; margin:0 0 4px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
      <div id="passwordRequirements" style="font-size:12px; color:#6b7280; margin:0 0 16px;">
        Password must be at least 8 characters
      </div>
      
      <label for="signupPasswordConfirm" style="display:block; font-weight:600; margin:0 0 4px; color:var(--text);">Confirm Password</label>
      <input type="password" id="signupPasswordConfirm" required style="width:100%; padding:10px; margin:0 0 20px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
      
      <div id="signupError" style="color:#ff3b30; margin:0 0 16px; display:none; font-size:14px;"></div>
      <div id="signupSuccess" style="color:#34c759; margin:0 0 16px; display:none; font-size:14px;"></div>
      
      <button type="submit" class="menu-button" style="width:100%;">
        <span class="button_top">Sign Up</span>
      </button>
    </form>
  </div>
</div>
    <!-- Trainer Customization Modal -->
    <div id="trainerModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1200; align-items:center; justify-content:center;">
      <div style="background:#fff; padding:24px; border-radius:12px; width:min(500px, 90%); max-height:80vh; overflow-y:auto;">
        <h3 style="margin:0 0 8px; color:var(--text);">Welcome, Trainer!</h3>
        <p style="margin:0 0 20px; color:var(--text-soft);">Let's set up your trainer profile!</p>
        
        <form id="trainerForm">
          <!-- Username -->
          <label for="trainerUsername" style="display:block; font-weight:600; margin:0 0 4px; color:var(--text);">Choose Your Trainer Name</label>
          <input type="text" id="trainerUsername" required minlength="3" maxlength="20" 
                 placeholder="3-20 characters" 
                 style="width:100%; padding:10px; margin:0 0 4px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
          <div id="usernameError" style="color:#ff3b30; font-size:12px; margin:0 0 16px; min-height:16px;"></div>
          
          <!-- Sprite Selection -->
          <label style="display:block; font-weight:600; margin:0 0 8px; color:var(--text);">Choose Your Pokémon Sprite</label>
          
          <!-- Search Box -->
          <div style="display:flex; gap:8px; margin:0 0 12px;">
            <input type="text" id="spriteSearch" 
                   placeholder="Search by name or Pokédex number..." 
                   style="flex:1; padding:10px; border:2px solid #d2deff; border-radius:8px; font-family:var(--font);">
            <label style="display:flex; align-items:center; gap:6px; padding:0 12px; background:var(--panel-soft); border-radius:8px; cursor:pointer;">
              <input type="checkbox" id="spriteShiny" style="cursor:pointer;">
              <span style="font-weight:600; color:var(--text);">✨ Shiny</span>
            </label>
          </div>
          
          <!-- Sprite Display -->
          <div style="background:var(--panel-soft); border-radius:12px; padding:20px; text-align:center; margin:0 0 20px;">
            <img id="selectedSprite" 
                 src="https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/25.png" 
                 alt="Selected Pokémon"
                 style="width:96px; height:96px; image-rendering:pixelated; margin:0 auto;">
            <div id="spriteName" style="margin:8px 0 0; font-weight:600; color:var(--text);">Pikachu (#25)</div>
          </div>
          
          <!-- Hidden fields to store selection -->
          <input type="hidden" id="selectedSpriteId" value="25">
          
          <!-- Submit Button -->
          <button type="submit" class="menu-button" style="width:100%;">
            <span class="button_top">Save Trainer Profile</span>
          </button>
        </form>
      </div>
    </div>
    <!-- Manage Saves Modal -->
    <div id="manageSavesModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1000; align-items:center; justify-content:center;">
      <div style="background:#fff; padding:16px; border-radius:12px; width: min(720px, 94%);">
        <h3 style="margin-top:0;">Continue / Manage Saves</h3>
        <p>Pick a slot to resume or delete. Starters saves resume on the Starters page.</p>
        <div id="manageSlotsGrid" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; margin:12px 0;">
          <!-- populated by JS -->
        </div>
        <div style="display:flex; gap:8px; justify-content:space-between; align-items:center;">
          <div>
            <button id="btnExportSaves" class="alt"><span class="button_top">Export Save Slots</span></button>
            <input type="file" id="importSavesInput" accept="application/json" style="display:none"/>
            <button id="btnImportSaves" class="alt"><span class="button_top">Import Save Slots</span></button>
          </div>
          <div>
            <button id="btnCloseManage"><span class="button_top">Close</span></button>
          </div>
        </div>
      </div>
    </div>

    <!-- Feedback Modal -->
<div id="feedbackModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1100; align-items:center; justify-content:center;">
  <div role="dialog" aria-modal="true" aria-labelledby="fbTitle"
       style="background:#fff; width:min(720px,94%); border-radius:12px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); position:relative;">
    <!-- X (close) -->
   <!-- X (close) -->
      <span id="fbClose" aria-label="Close"
      style="position:absolute; top:10px; right:10px; font-size:22px; line-height:1; cursor:pointer;">×</span>


    <h3 id="fbTitle" style="margin:0 28px 12px 0;">Submit Feedback</h3>

    <!-- Netlify-captured form -->
    <form id="feedbackForm"
      action="https://formspree.io/f/xrbaevlg"
      method="POST">
  <input type="hidden" name="_subject" value="PokeRankr Feedback">

  <!-- Feedback Type -->
  <label for="fbType" style="display:block; font-weight:600; margin:8px 0 4px;">Feedback Type</label>
  <select id="fbType" name="type" required style="width:100%; padding:10px;">
    <option value="">-- Choose --</option>
    <option>Bug</option>
    <option>Feature Request</option>
    <option>New Mode</option>
  </select>

  <!-- Feature Description -->
  <label for="fbMessage" style="display:block; font-weight:600; margin:12px 0 4px;">Feature Description</label>
  <small style="display:block; font-style:italic; color:#6b7280; margin-bottom:6px;">
    tell me about what you experienced or what you'd like to see!
  </small>
  <textarea id="fbMessage" name="message" required
          placeholder="Write your feedback…"
          style="width:100%; min-height:120px; padding:10px; resize:none;"></textarea>

  <div style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end;">
    <button type="button" id="feedbackCancel" class="alt"><span class="button_top">Cancel</span></button>
    <button type="submit"><span class="button_top">Send</span></button>
  </div>
</form>
  </div>
</div>


  </div> <!-- ✅ close loading-page -->

  <!-- ====== CONFIGURATION PAGE ====== -->
  <div id="config-page" class="page">
    <h1>Build Your Matchup!</h1>

    <!-- Global Shiny Settings -->
    <div class="settings">
      <label>
        <input type="checkbox" id="include-shinies">
        Include Shinies
      </label>
      <label>
        <input type="checkbox" id="shiny-only">
        Shiny Only
      </label>
    </div>

    <!-- Category Selection -->
    <div class="config-section">
      <label for="category">Select Category:</label>
      <select id="category">
        <option value="">-- Choose --</option>
        <option value="generation">Generation</option>
        <option value="starters">Starters</option>
        <option value="legendaries">Legendaries</option>
        <option value="type">Type</option>
      </select>
    </div>

    <!-- Dynamic Options -->
    <div id="extra-options"></div>

    <div class="button-row">
      <button id="btnStartRanking"><span class="button_top">Start Ranking</span></button>
      <button id="btnBackToMenu" class="alt"><span class="button_top">Back</span></button>
    </div>
  </div>
  <script src="js/auth.js"></script>
  <script src="js/sync.js"></script>
  <script>
 // Auth Modal Handlers
(function() {
  // Modal elements
  const welcomeModal = document.getElementById('welcomeModal');
  const localWarningModal = document.getElementById('localWarningModal');
  const authModal = document.getElementById('authModal');
  
  // Tab elements
  const tabLogin = document.getElementById('tabLogin');
  const tabSignup = document.getElementById('tabSignup');
  const loginForm = document.getElementById('loginForm');
  const signupForm = document.getElementById('signupForm');
  const authTitle = document.getElementById('authTitle');
  
  // Check if user has previously chosen to play locally
  const hasChosenLocal = localStorage.getItem('PR_PLAY_MODE') === 'local';
  
  // Initialize auth and show appropriate modal
  async function initializeAuth() {
    const user = await window.PokeRankrAuth.waitForAuth();
    
    if (!user && !hasChosenLocal) {
      // Show welcome modal for new/logged out users
      welcomeModal.style.display = 'flex';
    }
  }

  // Tab switching
  tabLogin?.addEventListener('click', () => {
    tabLogin.classList.add('active');
    tabLogin.style.borderBottomColor = '#2563eb';
    tabSignup.classList.remove('active');
    tabSignup.style.borderBottomColor = 'transparent';
    loginForm.style.display = 'block';
    signupForm.style.display = 'none';
    authTitle.textContent = 'Welcome Back!';
  });
  
  tabSignup?.addEventListener('click', () => {
    tabSignup.classList.add('active');
    tabSignup.style.borderBottomColor = '#2563eb';
    tabLogin.classList.remove('active');
    tabLogin.style.borderBottomColor = 'transparent';
    signupForm.style.display = 'block';
    loginForm.style.display = 'none';
    authTitle.textContent = 'Create Account';
  });

  // Show login button for non-logged-in users
function updateLoginButton() {
  const btnLoginSignup = document.getElementById('btnLoginSignup');
  const user = window.PokeRankrAuth.getCurrentUser();
  
  if (btnLoginSignup) {
    // Show button for ANY non-logged-in user, not just local mode
    btnLoginSignup.style.display = !user ? '' : 'none';
  }
}

  // Wire up the login button
  document.getElementById('btnLoginSignup')?.addEventListener('click', () => {
    authModal.style.display = 'flex';
  });

  // Update button visibility on auth changes
  window.PokeRankrAuth.onAuthChange(() => {
    updateLoginButton();
  });

  // Initial check
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(updateLoginButton, 100);
  });
  
  // Welcome modal handlers
  document.getElementById('btnWelcomeLogin')?.addEventListener('click', () => {
    welcomeModal.style.display = 'none';
    authModal.style.display = 'flex';
  });
  
  document.getElementById('btnWelcomeGuest')?.addEventListener('click', () => {
    welcomeModal.style.display = 'none';
    localWarningModal.style.display = 'flex';
  });
  
  // Local warning modal handlers
  document.getElementById('btnContinueLocally')?.addEventListener('click', () => {
    localStorage.setItem('PR_PLAY_MODE', 'local');
    localWarningModal.style.display = 'none';
  });
  
  document.getElementById('btnWarningLogin')?.addEventListener('click', () => {
    localWarningModal.style.display = 'none';
    authModal.style.display = 'flex';
  });
  
  // Auth modal handlers
  document.getElementById('authClose')?.addEventListener('click', () => {
    authModal.style.display = 'none';
    // If user closes auth without logging in, show welcome again
    if (!window.PokeRankrAuth.isLoggedIn() && !hasChosenLocal) {
      welcomeModal.style.display = 'flex';
    }
  });
  
  // Login form submission
  loginForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const email = document.getElementById('loginEmail').value;
    const password = document.getElementById('loginPassword').value;
    const errorDiv = document.getElementById('loginError');
    
    errorDiv.style.display = 'none';
    
    const { data, error } = await window.PokeRankrAuth.signIn(email, password);
    
    if (error) {
      errorDiv.textContent = error.message;
      errorDiv.style.display = 'block';
    } else {
      localStorage.removeItem('PR_PLAY_MODE'); // Clear local mode
      
      // Check if this is first login (no trainer data)
      const needsTrainerSetup = await checkNeedsTrainerSetup(data.user);
      
      authModal.style.display = 'none';
      if (needsTrainerSetup) {
        window.showTrainerCustomization();
      } else {
        // Existing user - sync their cloud data to local
        window.PokeRankrSync.syncCloudToLocal().then(() => {
          location.reload();
        });
      }
    }
  });
  
  // Signup form submission
  signupForm?.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const email = document.getElementById('signupEmail').value;
    const password = document.getElementById('signupPassword').value;
    const confirmPassword = document.getElementById('signupPasswordConfirm').value;
    const errorDiv = document.getElementById('signupError');
    const successDiv = document.getElementById('signupSuccess');
    
    errorDiv.style.display = 'none';
    successDiv.style.display = 'none';
    
    // Validate passwords match
    if (password !== confirmPassword) {
      errorDiv.textContent = 'Passwords do not match';
      errorDiv.style.display = 'block';
      return;
    }
    
    // Validate password complexity
    if (!validatePassword(password)) {
      errorDiv.textContent = 'Password must contain at least one lowercase letter, one uppercase letter, and one number';
      errorDiv.style.display = 'block';
      return;
    }
    
    const { data, error } = await window.PokeRankrAuth.signUp(email, password);
    
    if (error) {
      // Clean up Supabase's verbose error messages
      if (error.message.includes('already registered')) {
        errorDiv.textContent = 'This email is already registered. Please log in instead.';
      } else if (error.message.includes('Password should contain')) {
        errorDiv.textContent = 'Password must contain at least one lowercase letter, one uppercase letter, and one number';
      } else {
        errorDiv.textContent = error.message;
      }
      errorDiv.style.display = 'block';
    } else {
      successDiv.textContent = 'Sign up successful! Please check your email to verify your account (CHECK SPAM!)';
      successDiv.style.display = 'block';
      
      // Clear form
      signupForm.reset();
    }
  });

  
  
  // Password validation helper
  function validatePassword(password) {
    if (password.length < 6) return false;
    
    const hasLowercase = /[a-z]/.test(password);
    const hasUppercase = /[A-Z]/.test(password);
    const hasNumber = /\d/.test(password);
    
    return hasLowercase && hasUppercase && hasNumber;
  }
  
  // Live password validation feedback
  document.getElementById('signupPassword')?.addEventListener('input', (e) => {
    const password = e.target.value;
    const requirementsDiv = document.getElementById('passwordRequirements');
    
    if (password.length === 0) {
      requirementsDiv.textContent = 'Password must be at least 8 characters';
      requirementsDiv.style.color = '#6b7280';
      return;
    }
    
    const requirements = [];
    if (password.length < 8) requirements.push('at least 8 characters');
    if (!/[a-z]/.test(password)) requirements.push('one lowercase letter');
    if (!/[A-Z]/.test(password)) requirements.push('one uppercase letter');
    if (!/\d/.test(password)) requirements.push('one number');
    
    if (requirements.length === 0) {
      requirementsDiv.textContent = '✓ Password meets all requirements';
      requirementsDiv.style.color = '#34c759';
    } else {
      requirementsDiv.textContent = `Password needs: ${requirements.join(', ')}`;
      requirementsDiv.style.color = '#ff9500';
    }
  });

  
  
  // Helper function to check if user needs trainer setup
  async function checkNeedsTrainerSetup(user) {
    if (!user) return false;
    
    // Check if user has trainer data in Supabase
    const { data, error } = await window.PokeRankrAuth.supabase
      .from('user_profiles')
      .select('username')
      .eq('user_id', user.id)
      .maybeSingle();
    
    return !data || !data.username;
  }

  // Forgot password link handler
document.getElementById('forgotPasswordLink')?.addEventListener('click', (e) => {
  e.preventDefault();
  
  // Hide login form and tabs
  loginForm.style.display = 'none';
  const tabContainer = document.querySelector('#authModal .auth-tab')?.parentElement;
  if (tabContainer) {
    tabContainer.style.display = 'none';
  }
  
  // Show forgot password form
  const forgotForm = document.getElementById('forgotPasswordForm');
  if (forgotForm) {
    forgotForm.style.display = 'block';
  }
  authTitle.textContent = 'Reset Password';
  
  // Pre-fill email if user already entered it
  const loginEmail = document.getElementById('loginEmail').value;
  if (loginEmail) {
    document.getElementById('resetEmail').value = loginEmail;
  }
});

// Back to login button
document.getElementById('backToLogin')?.addEventListener('click', () => {
  // Show login form and tabs
  loginForm.style.display = 'block';
  const tabContainer = document.querySelector('#authModal .auth-tab')?.parentElement;
  if (tabContainer) {
    tabContainer.style.display = 'flex';
  }
  
  // Hide forgot password form
  const forgotForm = document.getElementById('forgotPasswordForm');
  if (forgotForm) {
    forgotForm.style.display = 'none';
  }
  authTitle.textContent = 'Welcome Back!';
  
  // Clear any messages
  const resetError = document.getElementById('resetError');
  const resetSuccess = document.getElementById('resetSuccess');
  if (resetError) resetError.style.display = 'none';
  if (resetSuccess) resetSuccess.style.display = 'none';
});

// Forgot password form submission
document.getElementById('forgotPasswordForm')?.addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const email = document.getElementById('resetEmail').value;
  const errorDiv = document.getElementById('resetError');
  const successDiv = document.getElementById('resetSuccess');
  
  if (errorDiv) errorDiv.style.display = 'none';
  if (successDiv) successDiv.style.display = 'none';
  
  const { data, error } = await window.PokeRankrAuth.supabase.auth.resetPasswordForEmail(email, {
    redirectTo: `${window.location.origin}/reset-password`,
  });
  
  if (error) {
    if (errorDiv) {
      errorDiv.textContent = error.message;
      errorDiv.style.display = 'block';
    }
  } else {
    if (successDiv) {
      successDiv.textContent = 'Password reset link sent! Check your email (and spam folder).';
      successDiv.style.display = 'block';
    }
    
    // Clear the form
    const resetEmailInput = document.getElementById('resetEmail');
    if (resetEmailInput) resetEmailInput.value = '';
    
    // Optionally, go back to login after a delay
    setTimeout(() => {
      document.getElementById('backToLogin')?.click();
    }, 5000);
  }
});
  

  // Start the auth check when page loads
  document.addEventListener('DOMContentLoaded', () => {
    // Small delay to ensure everything is loaded
    setTimeout(initializeAuth, 100);
  });
})();
  </script>
  <script>
    // Trainer Customization Handler
    (function() {
      const trainerModal = document.getElementById('trainerModal');
      const spriteSearch = document.getElementById('spriteSearch');
      const spriteShiny = document.getElementById('spriteShiny');
      const selectedSprite = document.getElementById('selectedSprite');
      const spriteName = document.getElementById('spriteName');
      const selectedSpriteId = document.getElementById('selectedSpriteId');
      const trainerUsername = document.getElementById('trainerUsername');
      const usernameError = document.getElementById('usernameError');
      
      // Pokemon data (1-1025)
      const pokemonNames = {
        1: "Bulbasaur", 2: "Ivysaur", 3: "Venusaur", 4: "Charmander", 5: "Charmeleon",
        6: "Charizard", 7: "Squirtle", 8: "Wartortle", 9: "Blastoise", 10: "Caterpie",
        25: "Pikachu", 150: "Mewtwo", 151: "Mew", // Add more as needed
        // We'll use PokeAPI for full list
      };
      
      // Fetch Pokemon names from PokeAPI
      async function loadPokemonNames() {
        try {
          const cached = localStorage.getItem('PR_POKEMON_NAMES');
          if (cached) {
            Object.assign(pokemonNames, JSON.parse(cached));
            return;
          }
          
          // Fetch from PokeAPI (limited to first 1025)
          const response = await fetch('https://pokeapi.co/api/v2/pokemon?limit=1025');
          const data = await response.json();
          
          data.results.forEach((pokemon, index) => {
            pokemonNames[index + 1] = pokemon.name.charAt(0).toUpperCase() + pokemon.name.slice(1);
          });
          
          localStorage.setItem('PR_POKEMON_NAMES', JSON.stringify(pokemonNames));
        } catch (error) {
          console.log('Using partial Pokemon list');
        }
      }
      
      // Update sprite display
      function updateSprite() {
        const id = selectedSpriteId.value || 25;
        const shiny = spriteShiny.checked;
        const baseUrl = shiny 
          ? 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/'
          : 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/';
        
        selectedSprite.src = `${baseUrl}${id}.png`;
        const name = pokemonNames[id] || `Pokemon`;
        spriteName.textContent = `${name} (#${id})`;
      }
      
      // Search handler
      let searchTimeout;
      spriteSearch.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const query = e.target.value.toLowerCase().trim();
          
          if (!query) {
            selectedSpriteId.value = 25;
            updateSprite();
            return;
          }
          
          // Check if it's a number
          const num = parseInt(query);
          if (!isNaN(num) && num >= 1 && num <= 1025) {
            selectedSpriteId.value = num;
            updateSprite();
            return;
          }
          
          // Search by name
          for (const [id, name] of Object.entries(pokemonNames)) {
            if (name.toLowerCase().includes(query)) {
              selectedSpriteId.value = id;
              updateSprite();
              break;
            }
          }
        }, 300);
      });
      
      // Shiny toggle
      spriteShiny.addEventListener('change', updateSprite);
      
      // Username validation
      trainerUsername.addEventListener('input', async (e) => {
        const username = e.target.value.trim();
        usernameError.textContent = '';
        
        if (username.length < 3) {
          usernameError.textContent = 'Username must be at least 3 characters';
          return;
        }
        
        if (username.length > 20) {
          usernameError.textContent = 'Username must be 20 characters or less';
          return;
        }
        
        // Check if username is taken
          if (username.length >= 3) {
            const { data } = await window.PokeRankrAuth.supabase
              .from('user_profiles')
              .select('username')
              .eq('username', username)
              .maybeSingle();
            
            if (data) {
              usernameError.textContent = 'This username is already taken';
            }
          }
      });
      
      // Form submission
document.getElementById('trainerForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const isEditMode = trainerModal.dataset.mode === 'edit';
  const username = trainerUsername.value.trim();
  const spriteId = parseInt(selectedSpriteId.value);
  const spriteShinyValue = document.getElementById('spriteShiny').checked;
  
  // Only validate username in create mode
  if (!isEditMode && usernameError.textContent) {
    return;
  }
  
  const user = window.PokeRankrAuth.getCurrentUser();
  if (!user) {
    alert('Please log in first');
    return;
  }
  
  if (isEditMode) {
    // Update existing profile
    const { error } = await window.PokeRankrAuth.supabase
      .from('user_profiles')
      .update({
        sprite_id: spriteId,
        sprite_shiny: spriteShinyValue,
        updated_at: new Date().toISOString()
      })
      .eq('user_id', user.id);
    
    if (error) {
      alert('Error updating profile: ' + error.message);
    } else {
      alert('Trainer card updated!');
      trainerModal.style.display = 'none';
      location.reload(); // Reload to show new sprite
    }
  } else {
    // Create new profile
    const { error } = await window.PokeRankrAuth.supabase
      .from('user_profiles')
      .insert({
        user_id: user.id,
        username: username,
        sprite_id: spriteId,
        sprite_shiny: spriteShinyValue
      });
    
    if (error) {
      alert('Error saving profile: ' + error.message);
    } else {
      trainerModal.style.display = 'none';
      location.reload();
    }
  }
});
      
      // Show trainer modal when needed
window.showTrainerCustomization = async function(editMode = false) {
  loadPokemonNames();
  
  if (editMode) {
    // Settings mode - load current profile
    const user = window.PokeRankrAuth.getCurrentUser();
    if (!user) {
      alert('Please log in to edit settings');
      return;
    }
    
    // Get current profile
    const { data: profile } = await window.PokeRankrAuth.supabase
      .from('user_profiles')
      .select('username, sprite_id, sprite_shiny')
      .eq('user_id', user.id)
      .maybeSingle();
    
    if (profile) {
      // Pre-fill form with current values
      trainerUsername.value = profile.username;
      trainerUsername.disabled = true; // Disable username editing
      trainerUsername.style.backgroundColor = '#f3f4f6'; // Visual indicator
      selectedSpriteId.value = profile.sprite_id;
      spriteShiny.checked = profile.sprite_shiny;
      updateSprite();
      
      // Update title for settings mode
      document.querySelector('#trainerModal h3').textContent = 'Update Your Trainer Card';
      document.querySelector('#trainerModal p').textContent = 'Change your Pokémon sprite:';
    }
  } else {
    // Initial setup mode
    trainerUsername.disabled = false;
    trainerUsername.style.backgroundColor = '';
    document.querySelector('#trainerModal h3').textContent = 'Welcome, Trainer!';
    document.querySelector('#trainerModal p').textContent = "Let's set up your trainer profile!";
  }
  
  // Store mode for form submission
  trainerModal.dataset.mode = editMode ? 'edit' : 'create';
  trainerModal.style.display = 'flex';
};
      
    // Check on email verification callback
window.addEventListener('hashchange', async () => {
  console.log('Hash changed:', window.location.hash);
  if (window.location.hash.includes('access_token') || window.location.hash.includes('type=signup')) {
    // Wait for auth to process
    setTimeout(async () => {
      const user = await window.PokeRankrAuth.waitForAuth();
      console.log('User after hash change:', user);
      
      if (user) {
        const { data } = await window.PokeRankrAuth.supabase
          .from('user_profiles')
          .select('username')
          .eq('user_id', user.id)
          .maybeSingle();
        
        console.log('Profile data:', data);
        
        if (!data) {
          // New user needs trainer setup
          console.log('Showing trainer customization');
          window.showTrainerCustomization();
        }
      }
    }, 1000);
  }
});

// Also listen for Supabase auth state changes
window.PokeRankrAuth.onAuthChange(async (user) => {
  console.log('Auth state changed:', user);
  if (user) {
    const { data } = await window.PokeRankrAuth.supabase
      .from('user_profiles')
      .select('username')
      .eq('user_id', user.id)
      .maybeSingle();
    
    if (!data && !window.trainerModalShown) {
      window.trainerModalShown = true;
      setTimeout(() => {
        window.showTrainerCustomization();
      }, 500);
    }
  }
});
      
      // Also check on page load
      if (window.location.hash.includes('access_token')) {
        window.location.hash = ''; // Clear the hash
        setTimeout(async () => {
          const user = await window.PokeRankrAuth.waitForAuth();
          if (user) {
            const { data } = await window.PokeRankrAuth.supabase
              .from('user_profiles')
              .select('username')
              .eq('user_id', user.id)
              .maybeSingle();
            
            if (!data) {
              window.showTrainerCustomization();
            }
          }
        }, 500);
      }
    })();
  </script>
  <script>
// User Header Handler
(function() {
  const userHeader = document.getElementById('userHeader');
  const headerSprite = document.getElementById('headerSprite');
  const headerUsername = document.getElementById('headerUsername');
  const btnLogout = document.getElementById('btnLogout');
  
  // Update header display
  async function updateUserHeader() {
    const user = window.PokeRankrAuth.getCurrentUser();
    
    if (!user) {
      userHeader.style.display = 'none';
      // Remove padding when logged out
      if (window.innerWidth <= 768) {
        document.querySelector('.loading-page')?.style.removeProperty('padding-bottom');
      }
      return;
    }
    
    // Get user profile
    const { data: profile } = await window.PokeRankrAuth.supabase
      .from('user_profiles')
      .select('username, sprite_id, sprite_shiny')
      .eq('user_id', user.id)
      .maybeSingle();
    
    if (profile) {
      const spriteUrl = profile.sprite_shiny
        ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/${profile.sprite_id}.png`
        : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${profile.sprite_id}.png`;
      
      headerSprite.src = spriteUrl;
      headerUsername.textContent = profile.username;
      userHeader.style.display = 'block';
      
      // Add padding to loading page on mobile when header is shown
      if (window.innerWidth <= 768) {
        const loadingPage = document.querySelector('.page.active');
        if (loadingPage && loadingPage.id === 'loading-page') {
          loadingPage.style.paddingBottom = '120px';
        }
      }
    }
  }
  
  // Handle window resize
  function handleResize() {
    const user = window.PokeRankrAuth.getCurrentUser();
    const loadingPage = document.querySelector('.page.active');
    
    if (user && window.innerWidth <= 768 && loadingPage?.id === 'loading-page') {
      loadingPage.style.paddingBottom = '120px';
    } else {
      loadingPage?.style.removeProperty('padding-bottom');
    }
  }
  
  // Logout handler
  btnLogout?.addEventListener('click', async () => {
    if (confirm('Are you sure you want to log out?')) {
      await window.PokeRankrAuth.signOut();
      localStorage.removeItem('PR_PLAY_MODE');
      location.reload();
    }
  });

  // Listen for auth changes
  window.PokeRankrAuth.onAuthChange((user) => {
    updateUserHeader();
  });
  
  // Listen for window resize
  window.addEventListener('resize', handleResize);

  // Initial check
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(updateUserHeader, 200);
  });
})();
  </script>
  <script>

    
  /* =========================
     App/version constants
     ========================= */
  const APP_NAME = 'PokeRankr';
  const APP_VERSION = '1.0.0';
  const SCHEMA_VERSION = 1;

  const pageLoading = document.getElementById('loading-page');
  const pageConfig = document.getElementById('config-page');
  const categorySelect = document.getElementById('category');
  const extraOptions = document.getElementById('extra-options');

  const includeShiniesCheckbox = document.getElementById('include-shinies');
  const shinyOnlyCheckbox = document.getElementById('shiny-only');

  const TYPES = [
    "Normal","Fire","Water","Electric","Grass","Ice","Fighting","Poison",
    "Ground","Flying","Psychic","Bug","Rock","Ghost","Dragon","Dark","Steel","Fairy"
  ];

  // Make shiny checkboxes mutually exclusive
  includeShiniesCheckbox.addEventListener('change', () => {
    if (includeShiniesCheckbox.checked) shinyOnlyCheckbox.checked = false;
  });
  shinyOnlyCheckbox.addEventListener('change', () => {
    if (shinyOnlyCheckbox.checked) includeShiniesCheckbox.checked = false;
  });

  // Navigation
  document.getElementById('btnStart').addEventListener('click', () => {
    pageLoading.classList.remove('active');
    pageConfig.classList.add('active');

    categorySelect.value = '';
    extraOptions.innerHTML = '';

    document.body.classList.add('config-mode');
    window.scrollTo({ top: 0, behavior: 'instant' || 'auto' });
  });

  document.getElementById('btnBackToMenu').addEventListener('click', () => {
    pageConfig.classList.remove('active');
    pageLoading.classList.add('active');
    document.body.classList.remove('config-mode');
  });

  // Build dynamic extra options
  categorySelect.addEventListener('change', () => {
    const cat = categorySelect.value;
    extraOptions.innerHTML = '';

    if (cat === 'generation') {
// Include "ALL" pseudo-gen + the normal gens
const supportedGens = ["ALL", 1, 2, 3, 4, 5, 6, 7, 8, 9];

// Build Gen buttons + (hidden-by-default) toggles row
extraOptions.innerHTML = `
  <div>
    <label>Select Generation:</label>
    <div class="category-buttons" id="genButtons" role="group" aria-label="Select Generation">
      ${supportedGens.map((g,i) => {
        const isAll = g === "ALL";
        const label = isAll ? "All" : `Gen ${g}`;
        return `
          <button
            type="button"
            class="menu-button gen-btn${i===0 ? ' selected' : ''}"
            data-gen="${g}"
            aria-pressed="${i===0 ? 'true' : 'false'}"
          >
            <span class="button_top">${label}</span>
          </button>
        `;
      }).join('')}
    </div>
  </div>

 <!-- Per-gen toggles (shown/hidden by JS) -->
<div class="settings" id="genToggleRow" style="display:none; margin-top:8px;">
  <label id="lblRegionalMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
  <span>Regional forms:</span>
  <select id="regional-mode">
    <option value="off">Off</option>
    <option value="include">Include</option>
  </select>
</label>

<label id="lblAltBattleMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
  <span>Alt/Battle forms:</span>
  <select id="altbattle-mode">
    <option value="off">Off</option>
    <option value="include">Include</option>
  </select>
</label>


  <!-- NEW: single G-Max mode control -->
  <label id="lblGmaxMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
    <span>G-Max:</span>
    <select id="gmax-mode">
      <option value="off">Off</option>
      <option value="include">+G-Max</option>
      <option value="only">G-Max only</option>
    </select>
  </label>
</div>
`;

  // Wire up gen selection
  const btns = extraOptions.querySelectorAll('.gen-btn');
  extraOptions.dataset.selectedGen = supportedGens[0];
  btns.forEach(btn => {
    btn.addEventListener('click', () => {
      btns.forEach(b => { b.classList.remove('selected'); b.setAttribute('aria-pressed','false'); });
      btn.classList.add('selected');
      btn.setAttribute('aria-pressed','true');
      extraOptions.dataset.selectedGen = btn.dataset.gen;

      // Re-evaluate which toggles should be visible for this gen
      updateGenTogglesVisibility();
    });
  });

  // Toggle visibility rules
 const REGIONAL_MIN_GEN = 7;
const ALT_BATTLE_GENS = new Set([7,8,9]);

const row              = extraOptions.querySelector('#genToggleRow');
const regionalModeSel  = extraOptions.querySelector('#regional-mode');
const altBattleModeSel = extraOptions.querySelector('#altbattle-mode');
const lblRegionalMode  = extraOptions.querySelector('#lblRegionalMode');
const lblAltBattleMode = extraOptions.querySelector('#lblAltBattleMode');

const gmaxModeSel = extraOptions.querySelector('#gmax-mode');
const lblGmaxMode = extraOptions.querySelector('#lblGmaxMode');


function updateGenTogglesVisibility() {
  const sel = extraOptions.dataset.selectedGen;
  const isAll = (sel === "ALL");
  const g = isAll ? NaN : parseInt(sel, 10);

  const showRegional  = isAll || (g >= REGIONAL_MIN_GEN);
  const showAltBattle = isAll || ALT_BATTLE_GENS.has(g);
  const showGmax      = isAll || g === 8;
  const allowOnly     = g === 8;

  // show/hide labels
  lblRegionalMode.style.display  = showRegional  ? '' : 'none';
  lblAltBattleMode.style.display = showAltBattle ? '' : 'none';
  lblGmaxMode.style.display      = showGmax ? '' : 'none';

  // guard “only” for G-Max
  const optOnly = gmaxModeSel?.querySelector('option[value="only"]');
  if (optOnly) {
    optOnly.disabled = !allowOnly;
    optOnly.hidden   = !allowOnly;
  }
  if (!allowOnly && gmaxModeSel?.value === 'only') {
    gmaxModeSel.value = 'include';
  }
// whole row on/off
  row.style.display = (showRegional || showAltBattle || showGmax) ? '' : 'none';

  // reset hidden controls to Off so we don’t leak state across gens
  if (!showRegional  && regionalModeSel)  regionalModeSel.value  = 'off';
  if (!showAltBattle && altBattleModeSel) altBattleModeSel.value = 'off';
  if (!showGmax && gmaxModeSel)           gmaxModeSel.value      = 'off';
}

  // Initialize visibility for the default selected gen
  updateGenTogglesVisibility();
}

if (cat === 'starters') {
  // 1) Ensure the switch CSS exists once (very small, ~10 rules)
  if (!document.getElementById('pr-toggle-css')) {
    const style = document.createElement('style');
    style.id = 'pr-toggle-css';
    style.textContent = `
      .pr-toggle{display:inline-flex;align-items:center;gap:10px;cursor:pointer;user-select:none}
      .pr-toggle input{position:absolute;opacity:0;width:0;height:0}
      .pr-switch{width:44px;height:24px;border-radius:9999px;background:#e5e7eb;position:relative;transition:background .18s ease}
      .pr-switch::after{content:"";position:absolute;top:3px;left:3px;width:18px;height:18px;border-radius:9999px;background:#fff;
        box-shadow:0 1px 2px rgba(0,0,0,.25);transition:transform .18s ease}
      .pr-toggle input:checked + .pr-switch{background:#2563eb}
      .pr-toggle input:checked + .pr-switch::after{transform:translateX(20px)}
      .pr-state{min-width:28px;font-size:.9rem;color:#6b7280}
      .pr-state[data-onoff="off"]::before{content:"Off"}
      .pr-state[data-onoff="on"]::before{content:"On"}
    `;
    document.head.appendChild(style);
  }

  // 2) Render the two switches
  extraOptions.innerHTML = `
    <div class="settings" style="display:flex;gap:20px;align-items:center;justify-content:center;flex-wrap:wrap;margin-top:6px;">
      <label class="pr-toggle">
        <input id="tgPikaEeveeCfg" type="checkbox" role="switch" aria-label="Add Pikachu and Eevee">
        <span class="pr-switch" aria-hidden="true"></span>
        <span>Add Pikachu & Eevee?</span>
        <span class="pr-state" id="tgPikaEeveeState" aria-hidden="true" data-onoff="off"></span>
      </label>

      <label class="pr-toggle">
        <input id="tgStarterLinesCfg" type="checkbox" role="switch" aria-label="Full Starter Line">
        <span class="pr-switch" aria-hidden="true"></span>
        <span>Full Starter Line</span>
        <span class="pr-state" id="tgStarterLinesState" aria-hidden="true" data-onoff="off"></span>
      </label>
    </div>
  `;

  // 3) Hydrate from previous choices (if any)
  const get = k => localStorage.getItem(k) === 'true';
  const elP = extraOptions.querySelector('#tgPikaEeveeCfg');
  const elL = extraOptions.querySelector('#tgStarterLinesCfg');
  const stP = extraOptions.querySelector('#tgPikaEeveeState');
  const stL = extraOptions.querySelector('#tgStarterLinesState');

  elP.checked = get('addPikaEevee');
  elL.checked = get('includeStarterLines');
  stP.dataset.onoff = elP.checked ? 'on' : 'off';
  stL.dataset.onoff = elL.checked ? 'on' : 'off';

  // 4) Live “On/Off” indicator (purely visual for now)
  elP.addEventListener('change', () => { stP.dataset.onoff = elP.checked ? 'on' : 'off'; });
  elL.addEventListener('change', () => { stL.dataset.onoff = elL.checked ? 'on' : 'off'; });
}


if (cat === 'legendaries') {
  extraOptions.innerHTML = `
    <div class="legendary-row" style="margin-bottom:12px;">
      <div class="toggle-row" style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
        <label for="mythicals" style="font-weight:600;">Mythicals:</label>
        <select id="mythicals">
          <option value="none" selected>Excluded</option>
          <option value="include">Included</option>
          <option value="only">Only</option>
        </select>

        <label style="font-weight:600;">Ultra Beasts:
          <select id="ubMode">
            <option value="exclude" selected>Excluded</option>
            <option value="include">Included</option>
          
            <option value="only">Only</option>
          </select>
        </label>
        <label style="font-weight:600;">Forms:
          <select id="formsMode">
            <option value="off">No Forms</option> <!-- Disable all forms -->
            <option value="gmax">+G-Max</option> <!-- Only G-Max forms -->
            <option value="mega">+Mega/Primal</option> <!-- Only Mega and Primal forms -->
            <option value="all">+All Forms</option> <!-- Include all forms (G-Max, Mega, Primal, etc.) -->
          </select>
        </label>
      </div>
    </div>
  `;

  // When "Mythicals = Only", disable Ultra Beasts selector (can’t be “only” both)
const ubSel   = extraOptions.querySelector('#ubMode');
const mythSel = extraOptions.querySelector('#mythicals');

function syncLegendaryDependencies(changed) {
  const mythMode = mythSel.value || 'none';
  const ubMode   = ubSel.value   || 'exclude';

  // If Mythicals = Only → lock UBs to Excluded and disable the selector
  if (mythMode === 'only') {
    ubSel.disabled = true;
    ubSel.value = 'exclude';
    mythSel.disabled = false; // allow user to switch back
    return;
  }

  // If UBs = Only → lock Mythicals to Excluded and disable the selector
  if (ubMode === 'only') {
    mythSel.disabled = true;
    mythSel.value = 'none';
    ubSel.disabled = false; // allow user to switch back
    return;
  }

  // Otherwise both enabled
  mythSel.disabled = false;
  ubSel.disabled = false;
}

// Wire up both selectors
mythSel.addEventListener('change', () => syncLegendaryDependencies('myth'));
ubSel.addEventListener('change', () => syncLegendaryDependencies('ub'));
syncLegendaryDependencies();
}



if (cat === 'type') {
  extraOptions.innerHTML = `
    <fieldset style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin: 6px 0 10px;">
      <legend style="font-weight:600;">Type Mode</legend>
      <label><input type="radio" name="typeMode" id="modeMono" value="mono" checked> Mono Type</label>
      <label><input type="radio" name="typeMode" id="modeDual" value="dual"> Dual Type</label>
    </fieldset>

    <div class="type-pickers" style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
      <label>Type 1:
        <select id="type1"></select>
      </label>
      <label id="type2Wrap" style="display:none;">Type 2:
        <select id="type2"></select>
      </label>
      <label id="strictWrap" style="display:inline-flex; align-items:center; gap:8px; margin-left:12px;">
        <input type="checkbox" id="strictMono">
        <span>Exclude dual‑types (strict mono)</span>
      </label>
    </div>
  `;

  const type1 = extraOptions.querySelector('#type1');
  const type2 = extraOptions.querySelector('#type2');

  [type1, type2].forEach(sel => {
    sel.innerHTML = `<option value="">Any</option>` + TYPES.map(t => `<option value="${t}">${t}</option>`).join('');
  });

  const modeMono   = extraOptions.querySelector('#modeMono');
  const modeDual   = extraOptions.querySelector('#modeDual');
  const type2Wrap  = extraOptions.querySelector('#type2Wrap');
  const strictWrap = extraOptions.querySelector('#strictWrap');

  function syncTypePickers() {
    const isDual = modeDual.checked;
    type2Wrap.style.display  = isDual ? 'inline-block' : 'none';
    strictWrap.style.display = isDual ? 'none' : 'inline-flex'; // only show strict for Mono
  }
  modeMono.addEventListener('change', syncTypePickers);
  modeDual.addEventListener('change', syncTypePickers);
  syncTypePickers();
}



  });

  // Helper for reading dynamic els
  function getEl(id){ return extraOptions.querySelector('#' + id); }

  // Start Ranking
document.getElementById('btnStartRanking').addEventListener('click', () => {
  const category = categorySelect.value || 'starters';

  const config = {
    includeShinies: !!includeShiniesCheckbox.checked,
    shinyOnly: !!shinyOnlyCheckbox.checked,
    category,
    filters: {}
  };

   if (category === 'generation') {
 const gen = extraOptions.dataset.selectedGen;
  if (!gen) { alert('Choose a generation.'); return; }
  config.filters.generation = (gen === "ALL") ? "ALL" : parseInt(gen, 10);

const regionalModeSel  = extraOptions.querySelector('#regional-mode');
const altBattleModeSel = extraOptions.querySelector('#altbattle-mode');
const gmaxModeSel      = extraOptions.querySelector('#gmax-mode');

const regionalMode  = regionalModeSel ? regionalModeSel.value  : 'off';     // 'off' | 'include'
const altBattleMode = altBattleModeSel ? altBattleModeSel.value : 'off';    // 'off' | 'include'
const gmaxMode      = gmaxModeSel ? gmaxModeSel.value : 'off';              // 'off' | 'include' | 'only'

config.toggles = {
  regionalMode,
  altBattleMode,
  gmax:     gmaxMode !== 'off',
  gmaxOnly: gmaxMode === 'only',
};


}


if (category === 'starters') {
  config.filters.starters = true;

  // Read our slide toggles if they exist (default to Off if they aren’t on the page)
  const pe = extraOptions.querySelector('#tgPikaEeveeCfg');     // “Add Pikachu & Eevee”
  const fl = extraOptions.querySelector('#tgStarterLinesCfg');  // “Full Starter Line”

  const addPikaEevee        = !!pe?.checked;
  const includeStarterLines  = !!fl?.checked;

  // Persist for the Starters page
  localStorage.setItem('addPikaEevee',       String(addPikaEevee));
  localStorage.setItem('includeStarterLines', String(includeStarterLines));

  // Also mirror into this run’s config (handy if you read rankConfig)
  config.toggles = { addPikaEevee, includeStarterLines };
}

  // ✅ NEW: capture Legendaries selectors → config.toggles
  if (category === 'legendaries') {
    const mythSel  = extraOptions.querySelector('#mythicals');
    const ubSel    = extraOptions.querySelector('#ubMode');
    const formsSel = extraOptions.querySelector('#formsMode');

    config.toggles = {
      mythMode:  mythSel  ? mythSel.value  : 'none',     // 'none' | 'include' | 'only'
      ubsMode:   ubSel    ? ubSel.value    : 'exclude',  // 'exclude' | 'include' | 'only'
      formsMode: formsSel ? formsSel.value : 'off'  // 'off' | 'gmax' | 'mega' | 'all'
    };
  }

if (category === 'type') {
  const isDual = !!getEl('modeDual')?.checked;
  const t1 = getEl('type1')?.value || '';
  const t2 = getEl('type2')?.value || '';
  const strictMono = !!getEl('strictMono')?.checked;

  if (!isDual) {
    if (!t1) { alert('Choose Type 1 for Mono.'); return; }
    config.filters.type = { mode: 'mono', types: [t1], strictMono };
  } else {
    if (!t1 || !t2) { alert('Choose both Type 1 and Type 2 for Dual.'); return; }
    if (t1 === t2) { alert('Type 1 and Type 2 must be different for Dual.'); return; }
    const types = [t1, t2].sort(); // normalize so Fire/Flying == Flying/Fire
    config.filters.type = { mode: 'dual', types };
  }
}


    localStorage.setItem('rankConfig', JSON.stringify(config));
    localStorage.setItem('includeShinies', config.includeShinies);
    localStorage.setItem('shinyOnly', config.shinyOnly);
    localStorage.setItem('category', config.category);

    const dest = (category === 'starters') ? 'starters.html' : 'ranker.html';
    window.location.href = dest;
  });

  /* =========================
     Storage helpers (v1)
     ========================= */

  function loadSavedArray(){
    try { return JSON.parse(localStorage.getItem('savedRankings') || '[]'); }
    catch { return []; }
  }
  function saveSavedArray(arr){
  localStorage.setItem('savedRankings', JSON.stringify(arr));
  // Auto-sync if logged in
  if (window.PokeRankrAuth && window.PokeRankrAuth.isLoggedIn()) {
    setTimeout(() => {
      window.PokeRankrSync.syncLocalToCloud();
    }, 500);
  }
}

  function canonicalKey(run){
    return run?.key || run?.id || `${(run?.category||'Unknown')}_${!!run?.includeShinies}_${!!run?.shinyOnly}`;
  }

  function parseWhen(run){
    const s = run?.lastModified || run?.date || new Date().toISOString();
    return new Date(s).getTime();
  }

  function collectAllRankingsFromLocal() {
    const map = {};
    const arr = loadSavedArray();
    for (const r of arr){
      if (!r) continue;
      const id = canonicalKey(r);
      map[id] = r;
    }
    return map;
  }

  function setAllRankingsToLocal(map) {
    const mergedArr = Object.values(map);
    saveSavedArray(mergedArr);
    localStorage.setItem('pokeRankr.rankings', JSON.stringify(map));
  }

  function buildExportPayload() {
    const arr = loadSavedArray();
    return {
      app: APP_NAME,
      appVersion: APP_VERSION,
      schemaVersion: SCHEMA_VERSION,
      exportedAt: new Date().toISOString(),
      rankings: arr
    };
  }

  function downloadRankings() {
    const data = buildExportPayload();
    if (!data.rankings.length) {
      alert('No saved rankings found to export.');
      return;
    }
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `pokeRankr-backup-${ts}.json`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  function isValidExport(obj) {
    return obj && typeof obj === 'object' &&
           obj.app === APP_NAME &&
           Array.isArray(obj.rankings);
  }

  // Merges imported rankings into existing using "Keep Newest" rule.
  function mergeKeepNewest(existingMap, importedArr){
    const out = { ...existingMap };
    for (const r of importedArr){
      if (!r || typeof r !== 'object') continue;
      const id = canonicalKey(r);
      const cur = out[id];
      if (!cur){
        out[id] = r;
        continue;
      }
      const curWhen = parseWhen(cur);
      const newWhen = parseWhen(r);
      if (newWhen > curWhen){
        out[id] = r;
      }
    }
    return out;
  }

  async function handleFileUpload(file) {
    try {
      const text = await file.text();
      const data = JSON.parse(text);

      if (!isValidExport(data)) {
        alert('Invalid file format. Please select a PokéRankr backup JSON.');
        return;
      }

      const existingMap = collectAllRankingsFromLocal();
      const merged = mergeKeepNewest(existingMap, data.rankings);
      setAllRankingsToLocal(merged);

      const before = Object.keys(existingMap).length;
      const after  = Object.keys(merged).length;
      const delta  = after - before;
      alert(`Import complete.\nUpdated or added ${Math.max(0, delta)} item(s) using "Keep Newest".`);

      if (after && confirm('Open Saved Rankings now?')) {
        window.location.href = 'saved.html';
      }
    } catch (err) {
      console.error(err);
      alert('Could not import that file.');
    }
  }

  // === Hook up Download / Upload buttons ===
  document.getElementById('btnDownload').addEventListener('click', downloadRankings);

  /* =========================
     Save Slots (global: 3)
     ========================= */
  const SAVE_SLOTS_KEY = 'PR_SAVE_SLOTS_V1';

  function slotsRead() {
    try {
      const arr = JSON.parse(localStorage.getItem(SAVE_SLOTS_KEY) || '[]');
      const out = Array.isArray(arr) ? arr.slice(0, 3) : [];
      while (out.length < 3) out.push(null);
      return out;
    } catch {
      return [null, null, null];
    }
  }
  function slotsWrite(slots) {
  localStorage.setItem(SAVE_SLOTS_KEY, JSON.stringify(slots));
  // Auto-sync if logged in
  if (window.PokeRankrAuth && window.PokeRankrAuth.isLoggedIn()) {
    setTimeout(() => {
      window.PokeRankrSync.syncLocalToCloud();
    }, 500);
  }
}
  function anySlotUsed() {
    return slotsRead().some(Boolean);
  }

  (function initManageSavesButton(){
    const btn = document.getElementById('btnManageSaves');
    if (!btn) return;
    if (anySlotUsed()) btn.style.display = '';
    btn.addEventListener('click', openManageSavesModal);
  })();

  function openManageSavesModal() {
    const m = document.getElementById('manageSavesModal');
    if (!m) return;
    m.style.display = 'flex';
    renderManageSlots();
  }
  function closeManageSavesModal() {
    const m = document.getElementById('manageSavesModal');
    if (!m) return;
    m.style.display = 'none';
  }
  document.getElementById('btnCloseManage')?.addEventListener('click', closeManageSavesModal);

 function spriteUrl(id, shiny) {
  return shiny
    ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/${id}.png`
    : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;
}
  function renderManageSlots() {
    const grid = document.getElementById('manageSlotsGrid');
    const slots = slotsRead();

    grid.innerHTML = slots.map((slot, i) => {
      if (!slot) {
        return `
          <div class="slot-card" data-idx="${i}">
  <div class="slot-body">Empty Slot</div>
  <div class="slot-actions">
    <button class="compact delete-btn" data-action="delete" data-idx="${i}" disabled>
      <span class="button_top">Delete</span>
    </button>
    <button class="compact resume-btn" data-action="resume" data-idx="${i}" disabled>
      <span class="button_top">Resume</span>
    </button>
  </div>
</div>

        `;
      }

      const a = slot.currentMatchup?.a;
      const b = slot.currentMatchup?.b;
      const savedAt = new Date(slot.meta?.savedAt || Date.now()).toLocaleString();
      const title = slot.label || 'Saved Run';
      const hrefHint = slot.type === 'starters' ? 'starters.html' : 'ranker.html';

      // Prefer new post-aware fields if present
let displayLabel = slot?.progress?.displayLabel;
let displayRemaining = slot?.progress?.displayRemaining;

// If not present (old saves), compute manually
if (!displayLabel) {
  const inPost = !!slot?.state?.postMode &&
                 (slot?.state?.post?.phase === 'RU' || slot?.state?.post?.phase === 'THIRD');

  if (inPost) {
    const total = typeof slot?.state?.post?.totalMatches === 'number'
      ? slot.state.post.totalMatches : 0;
    const done  = typeof slot?.state?.post?.doneMatches === 'number'
      ? slot.state.post.doneMatches : 0;
    const left  = Math.max(0, total - done - 1);

    displayLabel = (slot.state.post.phase === 'RU'
      ? 'Runner-up bracket — ' : 'Third-place bracket — ')
      + `${left} matchups remaining`;
    displayRemaining = left;
  } else {
    const rem = (slot?.progress && typeof slot.progress.remaining === 'number')
      ? slot.progress.remaining
      : (Array.isArray(slot?.state?.remaining) ? slot.state.remaining.length : null);
    if (rem !== null && rem !== undefined) {
      displayLabel = `${rem} matchups remaining`;
      displayRemaining = rem;
    }
  }
}

const remainingLine = displayLabel
  ? `<div style="font-size:.8rem; color:#374151; margin:6px 0 10px; text-align:center;">${displayLabel}</div>`
  : '';
return `
  <div class="slot-card" data-idx="${i}">
    <div class="slot-body" style="flex-direction:column; gap:4px;">
      <div style="display:flex; align-items:center; gap:8px; justify-content:center; min-height:120px;">
        ${a ? `<img src="${spriteUrl(a.id, a.shiny)}" alt="${a.name}" width="72" height="72">` : ''}
        <span style="font-weight:700;">VS</span>
        ${b ? `<img src="${spriteUrl(b.id, b.shiny)}" alt="${b.name}" width="72" height="72">` : ''}
      </div>
      <div style="font-size:.95rem; color:#111827; font-weight:600;">${title}</div>
      <div style="font-size:.8rem; color:#6b7280;">Saved ${savedAt}</div>
      ${remainingLine}
    </div>
    <div class="slot-actions">
      <button class="compact delete-btn" data-action="delete" data-idx="${i}">
        <span class="button_top">Delete</span>
      </button>
      <button class="compact resume-btn" data-action="resume" data-idx="${i}" data-href="${hrefHint}">
        <span class="button_top">Resume</span>
      </button>
    </div>
  </div>
`;


    }).join('');

    grid.onclick = (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const idx = +btn.dataset.idx;
      const action = btn.dataset.action;
      const slotsArr = slotsRead();

      if (action === 'delete') {
        if (slotsArr[idx] && !confirm('Delete this save slot?')) return;
        slotsArr[idx] = null;
        slotsWrite(slotsArr);
        renderManageSlots();
        if (!anySlotUsed()) document.getElementById('btnManageSaves').style.display = 'none';
        return;
      }

      if (action === 'resume') {
        const s = slotsArr[idx];
        if (!s) return;
        localStorage.setItem('PR_PENDING_RESUME_SLOT', String(idx));
        window.location.href = (s.type === 'starters') ? 'starters.html' : 'ranker.html';
      }
    };
  }

  function exportSaveSlots() {
    const data = {
      app: APP_NAME,
      appVersion: APP_VERSION,
      schemaVersion: SCHEMA_VERSION,
      exportedAt: new Date().toISOString(),
      saveSlots: slotsRead()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `pokeRankr-saveSlots-${ts}.json`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 1500);
  }
  function isValidSaveSlots(obj) {
    return obj && typeof obj === 'object' && obj.app === APP_NAME && Array.isArray(obj.saveSlots);
  }
  document.getElementById('btnExportSaves')?.addEventListener('click', exportSaveSlots);

  const importSavesInput = document.getElementById('importSavesInput');
  document.getElementById('btnImportSaves')?.addEventListener('click', () => importSavesInput.click());
  importSavesInput?.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      if (!isValidSaveSlots(data)) {
        alert('Invalid save-slots file.');
        importSavesInput.value = '';
        return;
      }
      slotsWrite((data.saveSlots || []).slice(0,3));
      renderManageSlots();
      document.getElementById('btnManageSaves').style.display = anySlotUsed() ? '' : 'none';
      alert('Save slots imported.');
    } catch (err) {
      console.error(err);
      alert('Could not import that file.');
    } finally {
      importSavesInput.value = '';
    }
  });

const uploadInput = document.getElementById('uploadInput');
const btnUpload = document.getElementById('btnUpload');

if (btnUpload && uploadInput) {
  btnUpload.addEventListener('click', () => uploadInput.click());

  uploadInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    handleFileUpload(file);
    uploadInput.value = '';
  });
} else {
  console.warn('Upload UI is missing: #btnUpload or #uploadInput not found.');
}
</script>
<script>
// Ensure all buttons have the .button_top styling + wire feedback modal
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('button:not(:has(.button_top))').forEach(btn => {
    const span = document.createElement('span');
    span.className = 'button_top';
    while (btn.firstChild) span.appendChild(btn.firstChild);
    btn.appendChild(span);
  });

  // === Feedback modal wiring ===
  const btnOpen  = document.getElementById('btnFeedback');
  const modal    = document.getElementById('feedbackModal');
  const closeX   = document.getElementById('fbClose');
  const cancel   = document.getElementById('feedbackCancel');
  const message  = document.getElementById('fbMessage');
  const form     = document.getElementById('feedbackForm');

  function openModal() {
    if (!modal) return;
    modal.style.display = 'flex';
    setTimeout(() => message?.focus(), 0);
  }
  function closeModal() {
    if (!modal) return;
    modal.style.display = 'none';
  }

  btnOpen?.addEventListener('click', openModal);
  closeX?.addEventListener('click', closeModal);
  cancel?.addEventListener('click', closeModal);

  // Close on click outside the dialog
  modal?.addEventListener('click', (e) => {
    if (e.target === modal) closeModal();
  });

  // Close on Esc
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeModal();
  });

  // === NEW: AJAX submit to Formspree (no page reload) ===
  form?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const endpoint = form.getAttribute('action');
    const data = new FormData(form);

    // Optional: include page context
    data.append('page', 'PokeRankr Home');

    try {
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Accept': 'application/json' },
        body: data
      });

      if (res.ok) {
        // success UX
        form.reset();
        closeModal();
        alert('Thanks! Your feedback was sent.'); // swap for a toast later if you want
      } else {
        alert('Could not send feedback. Please try again.');
      }
    } catch (err) {
      alert('Network error. Please try again.');
    }
  });
});

// === Badge Notification System ===
function updateBadgeNotification() {
  const notification = document.getElementById('badgeNotification');
  if (!notification) return;
  
  // Get achievements data
  const achievements = JSON.parse(localStorage.getItem('PR_ACHIEVEMENTS') || '{}');
  
  // Count new badges that haven't been viewed this session
  let newCount = 0;
  Object.keys(achievements).forEach(badgeId => {
    if (achievements[badgeId]?.isNew && !sessionStorage.getItem(`badge_${badgeId}_viewed`)) {
      newCount++;
    }
  });
  
  // Update notification bubble
  if (newCount > 0) {
    notification.textContent = newCount;
    notification.style.display = 'flex';
  } else {
    notification.style.display = 'none';
  }
}

// Check for new badges - using the correct logic from badges.html
function checkForNewBadges() {
  const achievements = JSON.parse(localStorage.getItem('PR_ACHIEVEMENTS') || '{}');
  const completions = JSON.parse(localStorage.getItem('PR_COMPLETIONS') || '[]');
  let hasNewBadge = false;
  
  // Use the SAME logic as badges.html
  const totalRankings = completions.length;
  
  // Boulder Badge - First ranking
  if (totalRankings >= 1 && !achievements.boulder?.unlocked) {
    achievements.boulder = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Cascade Badge - 5 rankings  
  if (totalRankings >= 5 && !achievements.cascade?.unlocked) {
    achievements.cascade = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Thunder Badge - 10 rankings
  if (totalRankings >= 10 && !achievements.thunder?.unlocked) {
    achievements.thunder = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Rainbow Badge - One ranking in each main category
  const categories = new Set(completions.map(c => c.category));
  if (categories.has('generation') && categories.has('starters') && 
      categories.has('legendaries') && categories.has('type') && !achievements.rainbow?.unlocked) {
    achievements.rainbow = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Soul Badge - Gen 1 Pokemon wins (but NOT in Gen 1-only category) - FIXED
  const hasGen1Winner = completions.some(c => 
    c.championId && c.championId <= 151 && 
    !(c.category === 'generation' && c.subcategory === 'generation-1')
  );
  if (hasGen1Winner && !achievements.soul?.unlocked) {
    achievements.soul = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Marsh Badge - Each Pokemon (#1-1025) must appear in at least one ranking
  const allSeenPokemonIds = new Set();
  completions.forEach(completion => {
    if (Array.isArray(completion.pokemonIds)) {
      completion.pokemonIds.forEach(id => allSeenPokemonIds.add(id));
    }
  });

  const hasAllPokemon = allSeenPokemonIds.size >= 1025;
  let foundAllDexNumbers = false;
  if (hasAllPokemon) {
    foundAllDexNumbers = true;
    for (let i = 1; i <= 1025; i++) {
      if (!allSeenPokemonIds.has(i)) {
        foundAllDexNumbers = false;
        break;
      }
    }
  }

  if (foundAllDexNumbers && !achievements.marsh?.unlocked) {
    achievements.marsh = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Volcano Badge - Shiny winner (not in shiny-only mode) - FIXED VERSION
  const shinyWinnerInMixed = completions.some(c => {
    if (!c.championShiny) return false;
    if (!c.includeShinies) return false;
    if (c.shinyOnly === true) return false;
    return true;
  });
  if (shinyWinnerInMixed && !achievements.volcano?.unlocked) {
    achievements.volcano = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Earth Badge - Complete comprehensive set
  const subcategories = new Set(completions.map(c => c.subcategory));
  const subcategoriesLc = new Set(
    [...subcategories].filter(Boolean).map(s => String(s).toLowerCase())
  );

  const TYPE_SLUGS = [
    'normal','fire','water','grass','electric','ice','fighting','poison','ground','flying',
    'psychic','bug','rock','ghost','dragon','dark','steel','fairy'
  ];

  const hasAllGens = ['1','2','3','4','5','6','7','8','9','all'].every(g =>
    subcategoriesLc.has(`generation-${g}`)
  );

  const hasStarters = categories.has('starters');

  const hasLegendaries = (() => {
    const ALL_IN_ONE = ['legendaries-all', 'legendaries-complete', 'legendaries-all-in-one'];
    const LEGENDARY_ONLY = ['legendaries-base', 'legendaries-only', 'legendaries'];
    const MYTHICALS     = ['legendaries-mythicals', 'mythicals', 'legendaries-mythical'];
    const ULTRA_BEASTS  = ['legendaries-ultra-beasts', 'legendaries-ultrabeasts', 'ultra-beasts', 'ultrabeasts'];

    const anyOf = arr => arr.some(s => subcategoriesLc.has(s));

    if (anyOf(ALL_IN_ONE)) return true;
    return anyOf(LEGENDARY_ONLY) && anyOf(MYTHICALS) && anyOf(ULTRA_BEASTS);
  })();

  const hasTypes = TYPE_SLUGS.every(t => subcategoriesLc.has(`type-${t}`));

  if (hasAllGens && hasStarters && hasLegendaries && hasTypes && !achievements.earth?.unlocked) {
    achievements.earth = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  if (hasNewBadge) {
    localStorage.setItem('PR_ACHIEVEMENTS', JSON.stringify(achievements));
  }
  
  return hasNewBadge;
}

// Update notification on page load
document.addEventListener('DOMContentLoaded', () => {
  checkForNewBadges();
  updateBadgeNotification();
});

// Also update when returning from other pages  
window.addEventListener('pageshow', () => {
  checkForNewBadges();  // Add this line!
  updateBadgeNotification();
});

// Settings button handler
document.getElementById('btnSettings')?.addEventListener('click', async () => {
  const user = window.PokeRankrAuth.getCurrentUser();
  
  if (!user) {
    alert('Please log in to access settings');
    return;
  }
  
  // Show trainer customization in edit mode
  window.showTrainerCustomization(true);
});
</script>
</body>
</html>