<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8" />
  <meta name="description" content="Put Pokémon head-to-head to find out who your REAL favorite is!">
  <!-- Open Graph for richer link previews -->
  <meta property="og:title" content="PokeRankr">
  <meta property="og:description" content="Put Pokémon head-to-head to find out who your REAL favorite is!">
  <meta property="og:image" content="https://yourdomain.com/Assets/pokerankr.png">
  <meta property="og:url" content="https://yourdomain.com/">
  <meta property="og:type" content="website">
  <title>PokéRankr - Head-to-Head Pokémon Ranking!</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
</head>
<body>

  <!-- ====== LOADING PAGE ====== -->
  <div id="loading-page" class="page active">
    <div class="logo">
  <img src="assets/logo.png" alt="PokéRankr Logo">
</div>
    <div class="menu-buttons">
  <button id="btnStart" class="menu-button"><span class="button_top">Start</span></button>
  <button id="btnManageSaves" class="menu-button" style="display:none;"><span class="button_top">Continue / Manage Saves</span></button>
  <button onclick="window.location.href='saved.html'"><span class="button_top">Saved Rankings</span></button>
  <button id="btnDownload" class="menu-button"><span class="button_top">Download Rankings</span></button>
  <button id="btnUpload" class="menu-button"><span class="button_top">Upload Rankings</span></button>
  <!-- NEW: hidden input specifically for Upload Rankings -->
  <input type="file" id="uploadInput" accept="application/json" style="display:none" />
</div>

    <!-- Manage Saves Modal -->
    <div id="manageSavesModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1000; align-items:center; justify-content:center;">
      <div style="background:#fff; padding:16px; border-radius:12px; width: min(720px, 94%);">
        <h3 style="margin-top:0;">Continue / Manage Saves</h3>
        <p>Pick a slot to resume or delete. Starters saves resume on the Starters page.</p>
        <div id="manageSlotsGrid" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; margin:12px 0;">
          <!-- populated by JS -->
        </div>
        <div style="display:flex; gap:8px; justify-content:space-between; align-items:center;">
          <div>
            <button id="btnExportSaves" class="alt"><span class="button_top">Export Save Slots</span></button>
            <input type="file" id="importSavesInput" accept="application/json" style="display:none"/>
            <button id="btnImportSaves" class="alt"><span class="button_top">Import Save Slots</span></button>
          </div>
          <div>
            <button id="btnCloseManage"><span class="button_top">Close</span></button>
          </div>
        </div>
      </div>
    </div>

  </div> <!-- ✅ close loading-page -->

  <!-- ====== CONFIGURATION PAGE ====== -->
  <div id="config-page" class="page">
    <h1>Build Your Matchup!</h1>

    <!-- Global Shiny Settings -->
    <div class="settings">
      <label>
        <input type="checkbox" id="include-shinies">
        Include Shinies
      </label>
      <label>
        <input type="checkbox" id="shiny-only">
        Shiny Only
      </label>
    </div>

    <!-- Category Selection -->
    <div class="config-section">
      <label for="category">Select Category:</label>
      <select id="category">
        <option value="">-- Choose --</option>
        <option value="generation">Generation</option>
        <option value="starters">Starters</option>
        <option value="legendaries">Legendaries</option>
        <option value="type">Type</option>
      </select>
    </div>

    <!-- Dynamic Options -->
    <div id="extra-options"></div>

    <div class="button-row">
      <button id="btnStartRanking"><span class="button_top">Start Ranking</span></button>
      <button id="btnBackToMenu" class="alt"><span class="button_top">Back</span></button>
    </div>
  </div>
  <script>
  /* =========================
     App/version constants
     ========================= */
  const APP_NAME = 'PokeRankr';
  const APP_VERSION = '1.0.0';
  const SCHEMA_VERSION = 1;

  const pageLoading = document.getElementById('loading-page');
  const pageConfig = document.getElementById('config-page');
  const categorySelect = document.getElementById('category');
  const extraOptions = document.getElementById('extra-options');

  const includeShiniesCheckbox = document.getElementById('include-shinies');
  const shinyOnlyCheckbox = document.getElementById('shiny-only');

  const TYPES = [
    "Normal","Fire","Water","Electric","Grass","Ice","Fighting","Poison",
    "Ground","Flying","Psychic","Bug","Rock","Ghost","Dragon","Dark","Steel","Fairy"
  ];

  // Make shiny checkboxes mutually exclusive
  includeShiniesCheckbox.addEventListener('change', () => {
    if (includeShiniesCheckbox.checked) shinyOnlyCheckbox.checked = false;
  });
  shinyOnlyCheckbox.addEventListener('change', () => {
    if (shinyOnlyCheckbox.checked) includeShiniesCheckbox.checked = false;
  });

  // Navigation
  document.getElementById('btnStart').addEventListener('click', () => {
    pageLoading.classList.remove('active');
    pageConfig.classList.add('active');

    categorySelect.value = '';
    extraOptions.innerHTML = '';

    document.body.classList.add('config-mode');
    window.scrollTo({ top: 0, behavior: 'instant' || 'auto' });
  });

  document.getElementById('btnBackToMenu').addEventListener('click', () => {
    pageConfig.classList.remove('active');
    pageLoading.classList.add('active');
    document.body.classList.remove('config-mode');
  });

  // Build dynamic extra options
  categorySelect.addEventListener('change', () => {
    const cat = categorySelect.value;
    extraOptions.innerHTML = '';

    if (cat === 'generation') {
// Include "ALL" pseudo-gen + the normal gens
const supportedGens = ["ALL", 1, 2, 3, 4, 5, 6, 7, 8, 9];

// Build Gen buttons + (hidden-by-default) toggles row
extraOptions.innerHTML = `
  <div>
    <label>Select Generation:</label>
    <div class="category-buttons" id="genButtons" role="group" aria-label="Select Generation">
      ${supportedGens.map((g,i) => {
        const isAll = g === "ALL";
        const label = isAll ? "All" : `Gen ${g}`;
        return `
          <button
            type="button"
            class="menu-button gen-btn${i===0 ? ' selected' : ''}"
            data-gen="${g}"
            aria-pressed="${i===0 ? 'true' : 'false'}"
          >
            <span class="button_top">${label}</span>
          </button>
        `;
      }).join('')}
    </div>
  </div>

 <!-- Per-gen toggles (shown/hidden by JS) -->
<div class="settings" id="genToggleRow" style="display:none; margin-top:8px;">
  <label id="lblRegionalMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
  <span>Regional forms:</span>
  <select id="regional-mode">
    <option value="off">Off</option>
    <option value="include">Include</option>
  </select>
</label>

<label id="lblAltBattleMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
  <span>Alt/Battle forms:</span>
  <select id="altbattle-mode">
    <option value="off">Off</option>
    <option value="include">Include</option>
  </select>
</label>


  <!-- NEW: single G-Max mode control -->
  <label id="lblGmaxMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
    <span>G-Max:</span>
    <select id="gmax-mode">
      <option value="off">Off</option>
      <option value="include">+G-Max</option>
      <option value="only">G-Max only</option>
    </select>
  </label>
</div>
`;

  // Wire up gen selection
  const btns = extraOptions.querySelectorAll('.gen-btn');
  extraOptions.dataset.selectedGen = supportedGens[0];
  btns.forEach(btn => {
    btn.addEventListener('click', () => {
      btns.forEach(b => { b.classList.remove('selected'); b.setAttribute('aria-pressed','false'); });
      btn.classList.add('selected');
      btn.setAttribute('aria-pressed','true');
      extraOptions.dataset.selectedGen = btn.dataset.gen;

      // Re-evaluate which toggles should be visible for this gen
      updateGenTogglesVisibility();
    });
  });

  // Toggle visibility rules
 const REGIONAL_MIN_GEN = 7;
const ALT_BATTLE_GENS = new Set([7,8,9]);

const row              = extraOptions.querySelector('#genToggleRow');
const regionalModeSel  = extraOptions.querySelector('#regional-mode');
const altBattleModeSel = extraOptions.querySelector('#altbattle-mode');
const lblRegionalMode  = extraOptions.querySelector('#lblRegionalMode');
const lblAltBattleMode = extraOptions.querySelector('#lblAltBattleMode');

const gmaxModeSel = extraOptions.querySelector('#gmax-mode');
const lblGmaxMode = extraOptions.querySelector('#lblGmaxMode');


function updateGenTogglesVisibility() {
  const sel = extraOptions.dataset.selectedGen;
  const isAll = (sel === "ALL");
  const g = isAll ? NaN : parseInt(sel, 10);

  const showRegional  = isAll || (g >= REGIONAL_MIN_GEN);
  const showAltBattle = isAll || ALT_BATTLE_GENS.has(g);
  const showGmax      = isAll || g === 8;
  const allowOnly     = g === 8;

  // show/hide labels
  lblRegionalMode.style.display  = showRegional  ? '' : 'none';
  lblAltBattleMode.style.display = showAltBattle ? '' : 'none';
  lblGmaxMode.style.display      = showGmax ? '' : 'none';

  // guard “only” for G-Max
  const optOnly = gmaxModeSel?.querySelector('option[value="only"]');
  if (optOnly) {
    optOnly.disabled = !allowOnly;
    optOnly.hidden   = !allowOnly;
  }
  if (!allowOnly && gmaxModeSel?.value === 'only') {
    gmaxModeSel.value = 'include';
  }
// whole row on/off
  row.style.display = (showRegional || showAltBattle || showGmax) ? '' : 'none';

  // reset hidden controls to Off so we don’t leak state across gens
  if (!showRegional  && regionalModeSel)  regionalModeSel.value  = 'off';
  if (!showAltBattle && altBattleModeSel) altBattleModeSel.value = 'off';
  if (!showGmax && gmaxModeSel)           gmaxModeSel.value      = 'off';
}

  // Initialize visibility for the default selected gen
  updateGenTogglesVisibility();
}

if (cat === 'starters') {
  // 1) Ensure the switch CSS exists once (very small, ~10 rules)
  if (!document.getElementById('pr-toggle-css')) {
    const style = document.createElement('style');
    style.id = 'pr-toggle-css';
    style.textContent = `
      .pr-toggle{display:inline-flex;align-items:center;gap:10px;cursor:pointer;user-select:none}
      .pr-toggle input{position:absolute;opacity:0;width:0;height:0}
      .pr-switch{width:44px;height:24px;border-radius:9999px;background:#e5e7eb;position:relative;transition:background .18s ease}
      .pr-switch::after{content:"";position:absolute;top:3px;left:3px;width:18px;height:18px;border-radius:9999px;background:#fff;
        box-shadow:0 1px 2px rgba(0,0,0,.25);transition:transform .18s ease}
      .pr-toggle input:checked + .pr-switch{background:#2563eb}
      .pr-toggle input:checked + .pr-switch::after{transform:translateX(20px)}
      .pr-state{min-width:28px;font-size:.9rem;color:#6b7280}
      .pr-state[data-onoff="off"]::before{content:"Off"}
      .pr-state[data-onoff="on"]::before{content:"On"}
    `;
    document.head.appendChild(style);
  }

  // 2) Render the two switches
  extraOptions.innerHTML = `
    <div class="settings" style="display:flex;gap:20px;align-items:center;justify-content:center;flex-wrap:wrap;margin-top:6px;">
      <label class="pr-toggle">
        <input id="tgPikaEeveeCfg" type="checkbox" role="switch" aria-label="Add Pikachu and Eevee">
        <span class="pr-switch" aria-hidden="true"></span>
        <span>Add Pikachu & Eevee?</span>
        <span class="pr-state" id="tgPikaEeveeState" aria-hidden="true" data-onoff="off"></span>
      </label>

      <label class="pr-toggle">
        <input id="tgStarterLinesCfg" type="checkbox" role="switch" aria-label="Full Starter Line">
        <span class="pr-switch" aria-hidden="true"></span>
        <span>Full Starter Line</span>
        <span class="pr-state" id="tgStarterLinesState" aria-hidden="true" data-onoff="off"></span>
      </label>
    </div>
  `;

  // 3) Hydrate from previous choices (if any)
  const get = k => localStorage.getItem(k) === 'true';
  const elP = extraOptions.querySelector('#tgPikaEeveeCfg');
  const elL = extraOptions.querySelector('#tgStarterLinesCfg');
  const stP = extraOptions.querySelector('#tgPikaEeveeState');
  const stL = extraOptions.querySelector('#tgStarterLinesState');

  elP.checked = get('addPikaEevee');
  elL.checked = get('includeStarterLines');
  stP.dataset.onoff = elP.checked ? 'on' : 'off';
  stL.dataset.onoff = elL.checked ? 'on' : 'off';

  // 4) Live “On/Off” indicator (purely visual for now)
  elP.addEventListener('change', () => { stP.dataset.onoff = elP.checked ? 'on' : 'off'; });
  elL.addEventListener('change', () => { stL.dataset.onoff = elL.checked ? 'on' : 'off'; });
}


if (cat === 'legendaries') {
  extraOptions.innerHTML = `
    <div class="legendary-row" style="margin-bottom:12px;">
      <div class="toggle-row" style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
        <label for="mythicals" style="font-weight:600;">Mythicals:</label>
        <select id="mythicals">
          <option value="none" selected>Excluded</option>
          <option value="include">Included</option>
          <option value="only">Only</option>
        </select>

        <label style="font-weight:600;">Ultra Beasts:
          <select id="ubMode">
            <option value="exclude" selected>Excluded</option>
            <option value="include">Included</option>
          
            <option value="only">Only</option>
          </select>
        </label>
        <label style="font-weight:600;">Forms:
          <select id="formsMode">
            <option value="off">No Forms</option> <!-- Disable all forms -->
            <option value="gmax">+G-Max</option> <!-- Only G-Max forms -->
            <option value="mega">+Mega/Primal</option> <!-- Only Mega and Primal forms -->
            <option value="all">+All Forms</option> <!-- Include all forms (G-Max, Mega, Primal, etc.) -->
          </select>
        </label>
      </div>
    </div>
  `;

  // When "Mythicals = Only", disable Ultra Beasts selector (can’t be “only” both)
const ubSel   = extraOptions.querySelector('#ubMode');
const mythSel = extraOptions.querySelector('#mythicals');

function syncLegendaryDependencies(changed) {
  const mythMode = mythSel.value || 'none';
  const ubMode   = ubSel.value   || 'exclude';

  // If Mythicals = Only → lock UBs to Excluded and disable the selector
  if (mythMode === 'only') {
    ubSel.disabled = true;
    ubSel.value = 'exclude';
    mythSel.disabled = false; // allow user to switch back
    return;
  }

  // If UBs = Only → lock Mythicals to Excluded and disable the selector
  if (ubMode === 'only') {
    mythSel.disabled = true;
    mythSel.value = 'none';
    ubSel.disabled = false; // allow user to switch back
    return;
  }

  // Otherwise both enabled
  mythSel.disabled = false;
  ubSel.disabled = false;
}

// Wire up both selectors
mythSel.addEventListener('change', () => syncLegendaryDependencies('myth'));
ubSel.addEventListener('change', () => syncLegendaryDependencies('ub'));
syncLegendaryDependencies();
}



if (cat === 'type') {
  extraOptions.innerHTML = `
    <fieldset style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin: 6px 0 10px;">
      <legend style="font-weight:600;">Type Mode</legend>
      <label><input type="radio" name="typeMode" id="modeMono" value="mono" checked> Mono Type</label>
      <label><input type="radio" name="typeMode" id="modeDual" value="dual"> Dual Type</label>
    </fieldset>

    <div class="type-pickers" style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
      <label>Type 1:
        <select id="type1"></select>
      </label>
      <label id="type2Wrap" style="display:none;">Type 2:
        <select id="type2"></select>
      </label>
      <label id="strictWrap" style="display:inline-flex; align-items:center; gap:8px; margin-left:12px;">
        <input type="checkbox" id="strictMono">
        <span>Exclude dual‑types (strict mono)</span>
      </label>
    </div>
  `;

  const type1 = extraOptions.querySelector('#type1');
  const type2 = extraOptions.querySelector('#type2');

  [type1, type2].forEach(sel => {
    sel.innerHTML = `<option value="">Any</option>` + TYPES.map(t => `<option value="${t}">${t}</option>`).join('');
  });

  const modeMono   = extraOptions.querySelector('#modeMono');
  const modeDual   = extraOptions.querySelector('#modeDual');
  const type2Wrap  = extraOptions.querySelector('#type2Wrap');
  const strictWrap = extraOptions.querySelector('#strictWrap');

  function syncTypePickers() {
    const isDual = modeDual.checked;
    type2Wrap.style.display  = isDual ? 'inline-block' : 'none';
    strictWrap.style.display = isDual ? 'none' : 'inline-flex'; // only show strict for Mono
  }
  modeMono.addEventListener('change', syncTypePickers);
  modeDual.addEventListener('change', syncTypePickers);
  syncTypePickers();
}



  });

  // Helper for reading dynamic els
  function getEl(id){ return extraOptions.querySelector('#' + id); }

  // Start Ranking
document.getElementById('btnStartRanking').addEventListener('click', () => {
  const category = categorySelect.value || 'starters';

  const config = {
    includeShinies: !!includeShiniesCheckbox.checked,
    shinyOnly: !!shinyOnlyCheckbox.checked,
    category,
    filters: {}
  };

   if (category === 'generation') {
 const gen = extraOptions.dataset.selectedGen;
  if (!gen) { alert('Choose a generation.'); return; }
  config.filters.generation = (gen === "ALL") ? "ALL" : parseInt(gen, 10);

const regionalModeSel  = extraOptions.querySelector('#regional-mode');
const altBattleModeSel = extraOptions.querySelector('#altbattle-mode');
const gmaxModeSel      = extraOptions.querySelector('#gmax-mode');

const regionalMode  = regionalModeSel ? regionalModeSel.value  : 'off';     // 'off' | 'include'
const altBattleMode = altBattleModeSel ? altBattleModeSel.value : 'off';    // 'off' | 'include'
const gmaxMode      = gmaxModeSel ? gmaxModeSel.value : 'off';              // 'off' | 'include' | 'only'

config.toggles = {
  regionalMode,
  altBattleMode,
  gmax:     gmaxMode !== 'off',
  gmaxOnly: gmaxMode === 'only',
};


}


if (category === 'starters') {
  config.filters.starters = true;

  // Read our slide toggles if they exist (default to Off if they aren’t on the page)
  const pe = extraOptions.querySelector('#tgPikaEeveeCfg');     // “Add Pikachu & Eevee”
  const fl = extraOptions.querySelector('#tgStarterLinesCfg');  // “Full Starter Line”

  const addPikaEevee        = !!pe?.checked;
  const includeStarterLines  = !!fl?.checked;

  // Persist for the Starters page
  localStorage.setItem('addPikaEevee',       String(addPikaEevee));
  localStorage.setItem('includeStarterLines', String(includeStarterLines));

  // Also mirror into this run’s config (handy if you read rankConfig)
  config.toggles = { addPikaEevee, includeStarterLines };
}

  // ✅ NEW: capture Legendaries selectors → config.toggles
  if (category === 'legendaries') {
    const mythSel  = extraOptions.querySelector('#mythicals');
    const ubSel    = extraOptions.querySelector('#ubMode');
    const formsSel = extraOptions.querySelector('#formsMode');

    config.toggles = {
      mythMode:  mythSel  ? mythSel.value  : 'none',     // 'none' | 'include' | 'only'
      ubsMode:   ubSel    ? ubSel.value    : 'exclude',  // 'exclude' | 'include' | 'only'
      formsMode: formsSel ? formsSel.value : 'off'  // 'off' | 'gmax' | 'mega' | 'all'
    };
  }

if (category === 'type') {
  const isDual = !!getEl('modeDual')?.checked;
  const t1 = getEl('type1')?.value || '';
  const t2 = getEl('type2')?.value || '';
  const strictMono = !!getEl('strictMono')?.checked;

  if (!isDual) {
    if (!t1) { alert('Choose Type 1 for Mono.'); return; }
    config.filters.type = { mode: 'mono', types: [t1], strictMono };
  } else {
    if (!t1 || !t2) { alert('Choose both Type 1 and Type 2 for Dual.'); return; }
    if (t1 === t2) { alert('Type 1 and Type 2 must be different for Dual.'); return; }
    const types = [t1, t2].sort(); // normalize so Fire/Flying == Flying/Fire
    config.filters.type = { mode: 'dual', types };
  }
}


    localStorage.setItem('rankConfig', JSON.stringify(config));
    localStorage.setItem('includeShinies', config.includeShinies);
    localStorage.setItem('shinyOnly', config.shinyOnly);
    localStorage.setItem('category', config.category);

    const dest = (category === 'starters') ? 'starters.html' : 'ranker.html';
    window.location.href = dest;
  });

  /* =========================
     Storage helpers (v1)
     ========================= */

  function loadSavedArray(){
    try { return JSON.parse(localStorage.getItem('savedRankings') || '[]'); }
    catch { return []; }
  }
  function saveSavedArray(arr){
    localStorage.setItem('savedRankings', JSON.stringify(arr));
  }

  function canonicalKey(run){
    return run?.key || run?.id || `${(run?.category||'Unknown')}_${!!run?.includeShinies}_${!!run?.shinyOnly}`;
  }

  function parseWhen(run){
    const s = run?.lastModified || run?.date || new Date().toISOString();
    return new Date(s).getTime();
  }

  function collectAllRankingsFromLocal() {
    const map = {};
    const arr = loadSavedArray();
    for (const r of arr){
      if (!r) continue;
      const id = canonicalKey(r);
      map[id] = r;
    }
    return map;
  }

  function setAllRankingsToLocal(map) {
    const mergedArr = Object.values(map);
    saveSavedArray(mergedArr);
    localStorage.setItem('pokeRankr.rankings', JSON.stringify(map));
  }

  function buildExportPayload() {
    const arr = loadSavedArray();
    return {
      app: APP_NAME,
      appVersion: APP_VERSION,
      schemaVersion: SCHEMA_VERSION,
      exportedAt: new Date().toISOString(),
      rankings: arr
    };
  }

  function downloadRankings() {
    const data = buildExportPayload();
    if (!data.rankings.length) {
      alert('No saved rankings found to export.');
      return;
    }
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `pokeRankr-backup-${ts}.json`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  function isValidExport(obj) {
    return obj && typeof obj === 'object' &&
           obj.app === APP_NAME &&
           Array.isArray(obj.rankings);
  }

  // Merges imported rankings into existing using "Keep Newest" rule.
  function mergeKeepNewest(existingMap, importedArr){
    const out = { ...existingMap };
    for (const r of importedArr){
      if (!r || typeof r !== 'object') continue;
      const id = canonicalKey(r);
      const cur = out[id];
      if (!cur){
        out[id] = r;
        continue;
      }
      const curWhen = parseWhen(cur);
      const newWhen = parseWhen(r);
      if (newWhen > curWhen){
        out[id] = r;
      }
    }
    return out;
  }

  async function handleFileUpload(file) {
    try {
      const text = await file.text();
      const data = JSON.parse(text);

      if (!isValidExport(data)) {
        alert('Invalid file format. Please select a PokéRankr backup JSON.');
        return;
      }

      const existingMap = collectAllRankingsFromLocal();
      const merged = mergeKeepNewest(existingMap, data.rankings);
      setAllRankingsToLocal(merged);

      const before = Object.keys(existingMap).length;
      const after  = Object.keys(merged).length;
      const delta  = after - before;
      alert(`Import complete.\nUpdated or added ${Math.max(0, delta)} item(s) using "Keep Newest".`);

      if (after && confirm('Open Saved Rankings now?')) {
        window.location.href = 'saved.html';
      }
    } catch (err) {
      console.error(err);
      alert('Could not import that file.');
    }
  }

  // === Hook up Download / Upload buttons ===
  document.getElementById('btnDownload').addEventListener('click', downloadRankings);

  /* =========================
     Save Slots (global: 3)
     ========================= */
  const SAVE_SLOTS_KEY = 'PR_SAVE_SLOTS_V1';

  function slotsRead() {
    try {
      const arr = JSON.parse(localStorage.getItem(SAVE_SLOTS_KEY) || '[]');
      const out = Array.isArray(arr) ? arr.slice(0, 3) : [];
      while (out.length < 3) out.push(null);
      return out;
    } catch {
      return [null, null, null];
    }
  }
  function slotsWrite(slots) {
    localStorage.setItem(SAVE_SLOTS_KEY, JSON.stringify(slots));
  }
  function anySlotUsed() {
    return slotsRead().some(Boolean);
  }

  (function initManageSavesButton(){
    const btn = document.getElementById('btnManageSaves');
    if (!btn) return;
    if (anySlotUsed()) btn.style.display = '';
    btn.addEventListener('click', openManageSavesModal);
  })();

  function openManageSavesModal() {
    const m = document.getElementById('manageSavesModal');
    if (!m) return;
    m.style.display = 'flex';
    renderManageSlots();
  }
  function closeManageSavesModal() {
    const m = document.getElementById('manageSavesModal');
    if (!m) return;
    m.style.display = 'none';
  }
  document.getElementById('btnCloseManage')?.addEventListener('click', closeManageSavesModal);

  function spriteUrl(id, shiny) {
    return shiny
      ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/shiny/${id}.png`
      : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${id}.png`;
  }
  function renderManageSlots() {
    const grid = document.getElementById('manageSlotsGrid');
    const slots = slotsRead();

    grid.innerHTML = slots.map((slot, i) => {
      if (!slot) {
        return `
          <div class="slot-card" data-idx="${i}">
  <div class="slot-body">Empty Slot</div>
  <div class="slot-actions">
    <button class="compact delete-btn" data-action="delete" data-idx="${i}" disabled>
      <span class="button_top">Delete</span>
    </button>
    <button class="compact resume-btn" data-action="resume" data-idx="${i}" disabled>
      <span class="button_top">Resume</span>
    </button>
  </div>
</div>

        `;
      }

      const a = slot.currentMatchup?.a;
      const b = slot.currentMatchup?.b;
      const savedAt = new Date(slot.meta?.savedAt || Date.now()).toLocaleString();
      const title = slot.label || 'Saved Run';
      const hrefHint = slot.type === 'starters' ? 'starters.html' : 'ranker.html';

      // Prefer new post-aware fields if present
let displayLabel = slot?.progress?.displayLabel;
let displayRemaining = slot?.progress?.displayRemaining;

// If not present (old saves), compute manually
if (!displayLabel) {
  const inPost = !!slot?.state?.postMode &&
                 (slot?.state?.post?.phase === 'RU' || slot?.state?.post?.phase === 'THIRD');

  if (inPost) {
    const total = typeof slot?.state?.post?.totalMatches === 'number'
      ? slot.state.post.totalMatches : 0;
    const done  = typeof slot?.state?.post?.doneMatches === 'number'
      ? slot.state.post.doneMatches : 0;
    const left  = Math.max(0, total - done - 1);

    displayLabel = (slot.state.post.phase === 'RU'
      ? 'Runner-up bracket — ' : 'Third-place bracket — ')
      + `${left} matchups remaining`;
    displayRemaining = left;
  } else {
    const rem = (slot?.progress && typeof slot.progress.remaining === 'number')
      ? slot.progress.remaining
      : (Array.isArray(slot?.state?.remaining) ? slot.state.remaining.length : null);
    if (rem !== null && rem !== undefined) {
      displayLabel = `${rem} matchups remaining`;
      displayRemaining = rem;
    }
  }
}

const remainingLine = displayLabel
  ? `<div style="font-size:.8rem; color:#374151; margin:6px 0 10px; text-align:center;">${displayLabel}</div>`
  : '';
return `
  <div class="slot-card" data-idx="${i}">
    <div class="slot-body" style="flex-direction:column; gap:4px;">
      <div style="display:flex; align-items:center; gap:8px; justify-content:center; min-height:120px;">
        ${a ? `<img src="${spriteUrl(a.id, a.shiny)}" alt="${a.name}" width="72" height="72">` : ''}
        <span style="font-weight:700;">VS</span>
        ${b ? `<img src="${spriteUrl(b.id, b.shiny)}" alt="${b.name}" width="72" height="72">` : ''}
      </div>
      <div style="font-size:.95rem; color:#111827; font-weight:600;">${title}</div>
      <div style="font-size:.8rem; color:#6b7280;">Saved ${savedAt}</div>
      ${remainingLine}
    </div>
    <div class="slot-actions">
      <button class="compact delete-btn" data-action="delete" data-idx="${i}">
        <span class="button_top">Delete</span>
      </button>
      <button class="compact resume-btn" data-action="resume" data-idx="${i}" data-href="${hrefHint}">
        <span class="button_top">Resume</span>
      </button>
    </div>
  </div>
`;


    }).join('');

    grid.onclick = (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const idx = +btn.dataset.idx;
      const action = btn.dataset.action;
      const slotsArr = slotsRead();

      if (action === 'delete') {
        if (slotsArr[idx] && !confirm('Delete this save slot?')) return;
        slotsArr[idx] = null;
        slotsWrite(slotsArr);
        renderManageSlots();
        if (!anySlotUsed()) document.getElementById('btnManageSaves').style.display = 'none';
        return;
      }

      if (action === 'resume') {
        const s = slotsArr[idx];
        if (!s) return;
        localStorage.setItem('PR_PENDING_RESUME_SLOT', String(idx));
        window.location.href = (s.type === 'starters') ? 'starters.html' : 'ranker.html';
      }
    };
  }

  function exportSaveSlots() {
    const data = {
      app: APP_NAME,
      appVersion: APP_VERSION,
      schemaVersion: SCHEMA_VERSION,
      exportedAt: new Date().toISOString(),
      saveSlots: slotsRead()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `pokeRankr-saveSlots-${ts}.json`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 1500);
  }
  function isValidSaveSlots(obj) {
    return obj && typeof obj === 'object' && obj.app === APP_NAME && Array.isArray(obj.saveSlots);
  }
  document.getElementById('btnExportSaves')?.addEventListener('click', exportSaveSlots);

  const importSavesInput = document.getElementById('importSavesInput');
  document.getElementById('btnImportSaves')?.addEventListener('click', () => importSavesInput.click());
  importSavesInput?.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      if (!isValidSaveSlots(data)) {
        alert('Invalid save-slots file.');
        importSavesInput.value = '';
        return;
      }
      slotsWrite((data.saveSlots || []).slice(0,3));
      renderManageSlots();
      document.getElementById('btnManageSaves').style.display = anySlotUsed() ? '' : 'none';
      alert('Save slots imported.');
    } catch (err) {
      console.error(err);
      alert('Could not import that file.');
    } finally {
      importSavesInput.value = '';
    }
  });

const uploadInput = document.getElementById('uploadInput');
const btnUpload = document.getElementById('btnUpload');

if (btnUpload && uploadInput) {
  btnUpload.addEventListener('click', () => uploadInput.click());

  uploadInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    handleFileUpload(file);
    uploadInput.value = '';
  });
} else {
  console.warn('Upload UI is missing: #btnUpload or #uploadInput not found.');
}
  </script>
  <script>
// Ensure all buttons have the .button_top styling
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('button:not(:has(.button_top))').forEach(btn => {
    const span = document.createElement('span');
    span.className = 'button_top';
    while (btn.firstChild) span.appendChild(btn.firstChild);
    btn.appendChild(span);
  });
});
</script>
</body>
</html>
