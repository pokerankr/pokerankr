<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8" />
  <meta name="description" content="Put Pokémon head-to-head to find out who your REAL favorite is!">
  <!-- Open Graph for richer link previews -->
  <meta property="og:title" content="PokeRankr">
  <meta property="og:description" content="Put Pokémon head-to-head to find out who your REAL favorite is!">
  <meta property="og:image" content="https://yourdomain.com/Assets/pokerankr.png">
  <meta property="og:url" content="https://yourdomain.com/">
  <meta property="og:type" content="website">
  <title>PokéRankr - Head-to-Head Pokémon Ranking!</title>
  <link rel="stylesheet" href="style.css" />
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

  <!-- ====== LOADING PAGE ====== -->
  <div id="loading-page" class="page active">
<!-- Auth Container - Fixed to top right corner -->
<div id="auth-container" style="position: fixed; top: 15px; right: 15px; z-index: 100;">
  <button id="loginButton" onclick="openAuthModal()" class="menu-button" style="min-width: 140px;">
    <span class="button_top">Login / Sign Up</span>
  </button>
  
  <!-- Trainer Card (hidden initially) -->
  <div id="trainerCard" style="display: none; align-items: center; gap: 10px; background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 12px; border: 2px solid #d2deff; box-shadow: 0 4px 12px rgba(0,0,0,0.15); min-width: 140px;">
    <img id="trainerSprite" src="" width="32" height="32" alt="Trainer">
    <span id="trainerName" style="font-weight: 600; color: #333;"></span>
    <button id="logoutButton" onclick="logout()" class="menu-button" style="font-size: 12px; padding: 4px 8px; margin-left: auto;">
      <span class="button_top">Logout</span>
    </button>
  </div>
</div>

<!-- Logo - Centered independently -->
<div class="logo">
  <img src="assets/logo.png" alt="PokeRankr Logo">
</div>
    <div class="menu-buttons">
  <div class="menu-primary">
    <button id="btnStart" class="menu-button"><span class="button_top">Start New Ranking</span></button>
    <button id="btnManageSaves" class="menu-button" style="display:none;"><span class="button_top">Continue / Manage Saves</span></button>
  </div>
  
  <div class="menu-secondary">
  <button onclick="window.location.href='saved.html'"><span class="button_top">Saved Rankings</span></button>
  <button onclick="window.location.href='badges.html'" id="btnBadges" style="position:relative;">
    <span class="button_top">Badges</span>
    <span id="badgeNotification" class="notification-bubble" style="display:none;"></span>
  </button>
  <button id="btnDownload" class="menu-button"><span class="button_top">Download</span></button>
  <button id="btnUpload" class="menu-button"><span class="button_top">Upload</span></button>
  <button id="btnFeedback" class="menu-button"><span class="button_top">Feedback</span></button>
  <button id="btnFeedback" class="menu-button"><span class="button_top">Settings</span></button>
</div>
</div>

<!-- Keep the hidden input for uploads -->
<input type="file" id="uploadInput" accept="application/json" style="display:none" />

    <!-- Manage Saves Modal -->
    <div id="manageSavesModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1000; align-items:center; justify-content:center;">
      <div style="background:#fff; padding:16px; border-radius:12px; width: min(720px, 94%);">
        <h3 style="margin-top:0;">Continue / Manage Saves</h3>
        <p>Pick a slot to resume or delete. Starters saves resume on the Starters page.</p>
        <div id="manageSlotsGrid" style="display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; margin:12px 0;">
          <!-- populated by JS -->
        </div>
        <div style="display:flex; gap:8px; justify-content:space-between; align-items:center;">
          <div>
            <button id="btnExportSaves" class="alt"><span class="button_top">Export Save Slots</span></button>
            <input type="file" id="importSavesInput" accept="application/json" style="display:none"/>
            <button id="btnImportSaves" class="alt"><span class="button_top">Import Save Slots</span></button>
          </div>
          <div>
            <button id="btnCloseManage"><span class="button_top">Close</span></button>
          </div>
        </div>
      </div>
    </div>

    <!-- Feedback Modal -->
<div id="feedbackModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.5); z-index:1100; align-items:center; justify-content:center;">
  <div role="dialog" aria-modal="true" aria-labelledby="fbTitle"
       style="background:#fff; width:min(720px,94%); border-radius:12px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); position:relative;">
    <!-- X (close) -->
   <!-- X (close) -->
      <span id="fbClose" aria-label="Close"
      style="position:absolute; top:10px; right:10px; font-size:22px; line-height:1; cursor:pointer;">×</span>


    <h3 id="fbTitle" style="margin:0 28px 12px 0;">Submit Feedback</h3>

    <!-- Netlify-captured form -->
    <form id="feedbackForm"
      action="https://formspree.io/f/xrbaevlg"
      method="POST">
  <input type="hidden" name="_subject" value="PokeRankr Feedback">

  <!-- Feedback Type -->
  <label for="fbType" style="display:block; font-weight:600; margin:8px 0 4px;">Feedback Type</label>
  <select id="fbType" name="type" required style="width:100%; padding:10px;">
    <option value="">-- Choose --</option>
    <option>Bug</option>
    <option>Feature Request</option>
    <option>New Mode</option>
  </select>

  <!-- Feature Description -->
  <label for="fbMessage" style="display:block; font-weight:600; margin:12px 0 4px;">Feature Description</label>
  <small style="display:block; font-style:italic; color:#6b7280; margin-bottom:6px;">
    tell me about what you experienced or what you'd like to see!
  </small>
  <textarea id="fbMessage" name="message" required
          placeholder="Write your feedback…"
          style="width:100%; min-height:120px; padding:10px; resize:none;"></textarea>

  <div style="display:flex; gap:8px; margin-top:12px; justify-content:flex-end;">
    <button type="button" id="feedbackCancel" class="alt"><span class="button_top">Cancel</span></button>
    <button type="submit"><span class="button_top">Send</span></button>
  </div>
</form>
  </div>
</div>


  </div> <!-- ✅ close loading-page -->

  <!-- ====== CONFIGURATION PAGE ====== -->
  <div id="config-page" class="page">
    <h1>Build Your Matchup!</h1>

    <!-- Global Shiny Settings -->
    <div class="settings">
      <label>
        <input type="checkbox" id="include-shinies">
        Include Shinies
      </label>
      <label>
        <input type="checkbox" id="shiny-only">
        Shiny Only
      </label>
    </div>

    <!-- Category Selection -->
    <div class="config-section">
      <label for="category">Select Category:</label>
      <select id="category">
        <option value="">-- Choose --</option>
        <option value="generation">Generation</option>
        <option value="starters">Starters</option>
        <option value="legendaries">Legendaries</option>
        <option value="type">Type</option>
      </select>
    </div>

    <!-- Dynamic Options -->
    <div id="extra-options"></div>

    <div class="button-row">
      <button id="btnStartRanking"><span class="button_top">Start Ranking</span></button>
      <button id="btnBackToMenu" class="alt"><span class="button_top">Back</span></button>
    </div>
  </div>
<script>
  /* =========================
     App/version constants
     ========================= */
  const APP_NAME = 'PokeRankr';
  const APP_VERSION = '1.0.0';
  const SCHEMA_VERSION = 1;

  /* =========================
     Supabase Client Setup
     ========================= */
  // Replace with your actual Supabase URL and anon key
  const supabaseUrl = 'https://nfelacjsvcilwfrqiftm.supabase.co'
  const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5mZWxhY2pzdmNpbHdmcnFpZnRtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2NDUxMzgsImV4cCI6MjA3MjIyMTEzOH0.sB-DDRwLGWxKksO9TCKf_7Tv3suDWxloYE0uEXpZ61w'
  const supabase = window.supabase.createClient(supabaseUrl, supabaseKey)
  
  // Make available globally
  window.supabase = supabase;
  /* =========================
   Authentication Functions
   ========================= */

// Global auth state
let currentUser = null;

// Modal functions
function openAuthModal() {
  const modal = document.getElementById('authModal');
  if (!modal) return;
  modal.style.display = 'flex';
}

function closeAuthModal() {
  const modal = document.getElementById('authModal');
  if (!modal) return;
  modal.style.display = 'none';
}

// Discord OAuth
async function signInWithDiscord() {
  try {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'discord',
      options: {
        redirectTo: window.location.origin + '/index.html'
      }
    });
    
    if (error) throw error;
    // OAuth will redirect, so no need to handle response here
  } catch (error) {
    console.error('Discord login error:', error);
    alert('Discord login failed: ' + error.message);
  }
}

// Email signup
async function signUpWithEmail() {
  const email = document.getElementById('emailInput').value.trim();
  const password = document.getElementById('passwordInput').value;
  
  if (!email || !password) {
    alert('Please enter both email and password');
    return;
  }
  
  try {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: window.location.origin + '/index.html'
      }
    });
    
    if (error) throw error;
    
    if (data.user && !data.user.email_confirmed_at) {
      alert('Check your email for verification link!');
    }
    
    closeAuthModal();
  } catch (error) {
    console.error('Signup error:', error);
    alert('Signup failed: ' + error.message);
  }
}

// Email login
async function signInWithEmail() {
  const email = document.getElementById('emailInput').value.trim();
  const password = document.getElementById('passwordInput').value;
  
  if (!email || !password) {
    alert('Please enter both email and password');
    return;
  }
  
  try {
    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password
    });
    
    if (error) throw error;
    
    closeAuthModal();
  } catch (error) {
    console.error('Login error:', error);
    alert('Login failed: ' + error.message);
  }
}

// Logout - Made globally accessible with better error handling
window.logout = async function() {
  console.log('Logout initiated...');
  try {
    // Clear local state first
    currentUser = null;
    
    // Attempt signout
    const { error } = await supabase.auth.signOut();
    
    if (error) {
      console.error('Supabase signout error:', error);
      // Even if there's an error, update the UI
      updateAuthUI();
      alert('Logout error: ' + error.message);
    } else {
      console.log('Logout successful');
      updateAuthUI();
      // Optionally refresh page to clear all state
      window.location.reload();
    }
  } catch (error) {
    console.error('Logout error caught:', error);
    // Force UI update even on error
    updateAuthUI();
    alert('Logout failed: ' + error.message);
  }
}

// Update UI based on auth state
function updateAuthUI() {
  const loginButton = document.getElementById('loginButton');
  const trainerCard = document.getElementById('trainerCard');
  const trainerName = document.getElementById('trainerName');
  const trainerSprite = document.getElementById('trainerSprite');
  
  if (currentUser) {
    // Show trainer card
    loginButton.style.display = 'none';
    trainerCard.style.display = 'flex';
    
    // Set trainer name (prefer username, fallback to email)
    const displayName = currentUser.user_metadata?.username || 
                       currentUser.email?.split('@')[0] || 
                       'Trainer';
    trainerName.textContent = displayName;
    
    // Set sprite (default to Pikachu for now)
    const pokemonId = currentUser.user_metadata?.favorite_pokemon_id || 25;
    trainerSprite.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemonId}.png`;
    
  } else {
    // Show login button
    loginButton.style.display = 'block';
    trainerCard.style.display = 'none';
  }
}

// Updated auth state check
async function checkAuthState() {
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    if (error) throw error;
    
    if (session) {
      currentUser = session.user;
      updateAuthUI();
      
      // Load cloud data first, then sync any local changes
      await loadDataFromCloud();
      
      console.log('Auth state checked - user logged in:', currentUser.email);
    } else {
      console.log('No active session');
    }
  } catch (error) {
    console.error('Auth check error:', error);
  }
}

// Debug helper - add this to check RLS policies
window.debugSupabase = async function() {
  if (!currentUser) {
    console.log('Not logged in');
    return;
  }
  
  console.log('Current user ID:', currentUser.id);
  console.log('Checking database access...');
  
  // Test each table
  const tables = ['user_achievements', 'user_completions', 'user_saved_rankings', 'user_save_slots'];
  
  for (const table of tables) {
    try {
      const { data, error } = await supabase
        .from(table)
        .select('*')
        .eq('user_id', currentUser.id);
      
      if (error) {
        console.error(`❌ ${table}: ${error.message}`);
      } else {
        console.log(`✅ ${table}: Can read (${data ? data.length : 0} rows)`);
      }
      
      // Test insert/update
      const testData = {
        user_id: currentUser.id,
        [`${table.includes('achievement') ? 'achievement' : table.includes('completion') ? 'completions' : table.includes('ranking') ? 'rankings' : 'slots'}_data`]: {},
        updated_at: new Date().toISOString()
      };
      
      const { error: upsertError } = await supabase
        .from(table)
        .upsert(testData, { onConflict: 'user_id' });
      
      if (upsertError) {
        console.error(`❌ ${table}: Cannot upsert - ${upsertError.message}`);
      } else {
        console.log(`✅ ${table}: Can upsert`);
      }
    } catch (err) {
      console.error(`Error testing ${table}:`, err);
    }
  }
}

// Simpler debug function that actually completes
window.testSupabase = async function() {
  if (!currentUser) {
    console.log('Not logged in');
    return;
  }
  
  console.log('Testing Supabase connection...');
  console.log('User ID:', currentUser.id);
  
  try {
    // Test read
    const { data, error } = await supabase
      .from('user_saved_rankings')
      .select('*')
      .eq('user_id', currentUser.id)
      .maybeSingle();
    
    if (error) {
      console.error('Read error:', error);
    } else {
      console.log('Read successful. Data:', data);
      if (data) {
        console.log('Rankings in cloud:', data.rankings_data?.length || 0);
      }
    }
    
    // Force sync
    console.log('Forcing sync...');
    await syncDataToCloud();
    console.log('Sync complete');
    
  } catch (err) {
    console.error('Test error:', err);
  }
}
/* =========================
   Cloud Data Sync Functions (FIXED)
   ========================= */

// Sync local data to cloud - FIXED to ensure correct data format
async function syncDataToCloud() {
  if (!currentUser) {
    console.log('No user logged in, skipping sync');
    return;
  }

  console.log('Starting sync to cloud...');
  
  try {
    // Get all local data
    const achievements = JSON.parse(localStorage.getItem('PR_ACHIEVEMENTS') || '{}');
    const completions = JSON.parse(localStorage.getItem('PR_COMPLETIONS') || '[]');
    const savedRankings = JSON.parse(localStorage.getItem('savedRankings') || '[]');
    const saveSlots = JSON.parse(localStorage.getItem('PR_SAVE_SLOTS_V1') || '[null,null,null]');

    console.log('Data to sync:', {
      achievements: Object.keys(achievements).length,
      completions: completions.length,
      savedRankings: savedRankings.length,
      saveSlots: saveSlots.filter(Boolean).length
    });

    const promises = [];

    // Always sync ALL data, even if empty (to overwrite bad data)
    promises.push(
      supabase.from('user_achievements').upsert({
        user_id: currentUser.id,
        achievement_data: achievements,
        updated_at: new Date().toISOString()
      }, { onConflict: 'user_id' })
    );

    promises.push(
      supabase.from('user_completions').upsert({
        user_id: currentUser.id,
        completions_data: completions,
        updated_at: new Date().toISOString()
      }, { onConflict: 'user_id' })
    );

    promises.push(
      supabase.from('user_saved_rankings').upsert({
        user_id: currentUser.id,
        rankings_data: savedRankings,
        updated_at: new Date().toISOString()
      }, { onConflict: 'user_id' })
    );

    promises.push(
      supabase.from('user_save_slots').upsert({
        user_id: currentUser.id,
        slots_data: saveSlots,
        updated_at: new Date().toISOString()
      }, { onConflict: 'user_id' })
    );

    const results = await Promise.allSettled(promises);
    
    // Log each result
    const tableNames = ['achievements', 'completions', 'saved_rankings', 'save_slots'];
    results.forEach((result, index) => {
      if (result.status === 'rejected') {
        console.error(`❌ Error syncing ${tableNames[index]}:`, result.reason);
      } else if (result.value?.error) {
        console.error(`❌ Error syncing ${tableNames[index]}:`, result.value.error);
      } else {
        console.log(`✅ Successfully synced ${tableNames[index]}`);
      }
    });
    
    console.log('Data sync to cloud completed');

  } catch (error) {
    console.error('Error in syncDataToCloud:', error);
  }
}

// FIXED: Load data from cloud - handle missing data gracefully
async function loadDataFromCloud() {
  if (!currentUser) return;

  try {
    // Fetch all user data from cloud - use maybeSingle() instead of single()
    const [achievementsRes, completionsRes, rankingsRes, slotsRes] = await Promise.all([
      supabase.from('user_achievements')
        .select('*')
        .eq('user_id', currentUser.id)
        .maybeSingle(), // Use maybeSingle() to handle no data case
      
      supabase.from('user_completions')
        .select('*')
        .eq('user_id', currentUser.id)
        .maybeSingle(),
      
      supabase.from('user_saved_rankings')
        .select('*')
        .eq('user_id', currentUser.id)
        .maybeSingle(),
      
      supabase.from('user_save_slots')
        .select('*')
        .eq('user_id', currentUser.id)
        .maybeSingle()
    ]);

    let hasCloudData = false;

    // Check each response and only update if data exists
    if (achievementsRes.data && achievementsRes.data.achievement_data) {
  const achievements = achievementsRes.data.achievement_data;
  // Ensure it's an object
  if (typeof achievements === 'object' && !Array.isArray(achievements)) {
    localStorage.setItem('PR_ACHIEVEMENTS', JSON.stringify(achievements));
    hasCloudData = true;
    console.log('Loaded achievements from cloud');
  }
}

if (completionsRes.data && completionsRes.data.completions_data) {
  const completions = completionsRes.data.completions_data;
  // Ensure it's an array
  if (Array.isArray(completions)) {
    localStorage.setItem('PR_COMPLETIONS', JSON.stringify(completions));
    hasCloudData = true;
    console.log('Loaded completions from cloud');
  } else if (typeof completions === 'object') {
    // If it's an object, try to convert to array
    const completionsArray = Object.values(completions);
    localStorage.setItem('PR_COMPLETIONS', JSON.stringify(completionsArray));
    hasCloudData = true;
    console.log('Loaded completions from cloud (converted from object)');
  }
}

if (rankingsRes.data && rankingsRes.data.rankings_data) {
  const rankings = rankingsRes.data.rankings_data;
  // Ensure it's an array
  if (Array.isArray(rankings)) {
    localStorage.setItem('savedRankings', JSON.stringify(rankings));
    hasCloudData = true;
    console.log('Loaded rankings from cloud');
  } else if (typeof rankings === 'object') {
    // If it's an object, convert to array
    const rankingsArray = Object.values(rankings);
    localStorage.setItem('savedRankings', JSON.stringify(rankingsArray));
    hasCloudData = true;
    console.log('Loaded rankings from cloud (converted from object)');
  }
}

if (slotsRes.data && slotsRes.data.slots_data) {
  const slots = slotsRes.data.slots_data;
  // Ensure it's an array with 3 slots
  if (Array.isArray(slots)) {
    while (slots.length < 3) slots.push(null);
    localStorage.setItem('PR_SAVE_SLOTS_V1', JSON.stringify(slots.slice(0, 3)));
    hasCloudData = true;
    console.log('Loaded save slots from cloud');
  }
}
    if (hasCloudData) {
      console.log('Data loaded from cloud successfully');
      // Update UI to reflect new data
      if (typeof checkForNewBadges !== 'undefined') {
        checkForNewBadges();
      }
      if (typeof updateBadgeNotification !== 'undefined') {
        updateBadgeNotification();
      }
    } else {
      console.log('No cloud data found for user - will sync local data to cloud');
      // If no cloud data exists, sync local data to cloud
      await syncDataToCloud();
    }

  } catch (error) {
    console.error('Error loading from cloud:', error);
  }
}

// Auto-sync data when user makes changes
async function autoSyncToCloud() {
  if (!currentUser) return;
  
  // Debounce to avoid too many API calls
  if (autoSyncToCloud.timeout) {
    clearTimeout(autoSyncToCloud.timeout);
  }
  
  autoSyncToCloud.timeout = setTimeout(() => {
    syncDataToCloud();
  }, 2000); // Sync 2 seconds after last change
}

// Override localStorage.setItem to trigger auto-sync - WITH LOGGING
const originalSetItem = localStorage.setItem;
localStorage.setItem = function(key, value) {
  originalSetItem.call(this, key, value);
  
  // Only auto-sync for PokeRankr data
  const syncKeys = ['PR_ACHIEVEMENTS', 'PR_COMPLETIONS', 'savedRankings', 'PR_SAVE_SLOTS_V1'];
  if (syncKeys.includes(key) && currentUser) {
    console.log(`LocalStorage updated: ${key}, triggering auto-sync...`);
    autoSyncToCloud();
  }
};
// Listen for auth state changes
// Update the existing auth state change listener
supabase.auth.onAuthStateChange(async (event, session) => {
  if (event === 'SIGNED_IN' && session) {
    currentUser = session.user;
    updateAuthUI();
    
    // NEW: Sync data on sign in
    await loadDataFromCloud();
    await syncDataToCloud();
    
  } else if (event === 'SIGNED_OUT') {
    currentUser = null;
    updateAuthUI();
  }
});

// Initialize auth check on page load
document.addEventListener('DOMContentLoaded', () => {
  // Wire up auth modal buttons
  document.getElementById('discordLoginBtn')?.addEventListener('click', signInWithDiscord);
  document.getElementById('emailSignUpBtn')?.addEventListener('click', signUpWithEmail);
  document.getElementById('emailLoginBtn')?.addEventListener('click', signInWithEmail);
  
  // Close modal on outside click
  document.getElementById('authModal')?.addEventListener('click', (e) => {
    if (e.target.id === 'authModal') closeAuthModal();
  });
  checkAuthState();
});
  const pageLoading = document.getElementById('loading-page');
  const pageConfig = document.getElementById('config-page');
  const categorySelect = document.getElementById('category');
  const extraOptions = document.getElementById('extra-options');

  const includeShiniesCheckbox = document.getElementById('include-shinies');
  const shinyOnlyCheckbox = document.getElementById('shiny-only');

  const TYPES = [
    "Normal","Fire","Water","Electric","Grass","Ice","Fighting","Poison",
    "Ground","Flying","Psychic","Bug","Rock","Ghost","Dragon","Dark","Steel","Fairy"
  ];

  // Make shiny checkboxes mutually exclusive
  includeShiniesCheckbox.addEventListener('change', () => {
    if (includeShiniesCheckbox.checked) shinyOnlyCheckbox.checked = false;
  });
  shinyOnlyCheckbox.addEventListener('change', () => {
    if (shinyOnlyCheckbox.checked) includeShiniesCheckbox.checked = false;
  });

  // Navigation
  document.getElementById('btnStart').addEventListener('click', () => {
    pageLoading.classList.remove('active');
    pageConfig.classList.add('active');

    categorySelect.value = '';
    extraOptions.innerHTML = '';

    document.body.classList.add('config-mode');
    window.scrollTo({ top: 0, behavior: 'instant' || 'auto' });
  });

  document.getElementById('btnBackToMenu').addEventListener('click', () => {
    pageConfig.classList.remove('active');
    pageLoading.classList.add('active');
    document.body.classList.remove('config-mode');
  });

  // Build dynamic extra options
  categorySelect.addEventListener('change', () => {
    const cat = categorySelect.value;
    extraOptions.innerHTML = '';

    if (cat === 'generation') {
// Include "ALL" pseudo-gen + the normal gens
const supportedGens = ["ALL", 1, 2, 3, 4, 5, 6, 7, 8, 9];

// Build Gen buttons + (hidden-by-default) toggles row
extraOptions.innerHTML = `
  <div>
    <label>Select Generation:</label>
    <div class="category-buttons" id="genButtons" role="group" aria-label="Select Generation">
      ${supportedGens.map((g,i) => {
        const isAll = g === "ALL";
        const label = isAll ? "All" : `Gen ${g}`;
        return `
          <button
            type="button"
            class="menu-button gen-btn${i===0 ? ' selected' : ''}"
            data-gen="${g}"
            aria-pressed="${i===0 ? 'true' : 'false'}"
          >
            <span class="button_top">${label}</span>
          </button>
        `;
      }).join('')}
    </div>
  </div>

 <!-- Per-gen toggles (shown/hidden by JS) -->
<div class="settings" id="genToggleRow" style="display:none; margin-top:8px;">
  <label id="lblRegionalMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
  <span>Regional forms:</span>
  <select id="regional-mode">
    <option value="off">Off</option>
    <option value="include">Include</option>
  </select>
</label>

<label id="lblAltBattleMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
  <span>Alt/Battle forms:</span>
  <select id="altbattle-mode">
    <option value="off">Off</option>
    <option value="include">Include</option>
  </select>
</label>


  <!-- NEW: single G-Max mode control -->
  <label id="lblGmaxMode" style="display:none; display:inline-flex; align-items:center; gap:8px;">
    <span>G-Max:</span>
    <select id="gmax-mode">
      <option value="off">Off</option>
      <option value="include">+G-Max</option>
      <option value="only">G-Max only</option>
    </select>
  </label>
</div>
`;

  // Wire up gen selection
  const btns = extraOptions.querySelectorAll('.gen-btn');
  extraOptions.dataset.selectedGen = supportedGens[0];
  btns.forEach(btn => {
    btn.addEventListener('click', () => {
      btns.forEach(b => { b.classList.remove('selected'); b.setAttribute('aria-pressed','false'); });
      btn.classList.add('selected');
      btn.setAttribute('aria-pressed','true');
      extraOptions.dataset.selectedGen = btn.dataset.gen;

      // Re-evaluate which toggles should be visible for this gen
      updateGenTogglesVisibility();
    });
  });

  // Toggle visibility rules
 const REGIONAL_MIN_GEN = 7;
const ALT_BATTLE_GENS = new Set([7,8,9]);

const row              = extraOptions.querySelector('#genToggleRow');
const regionalModeSel  = extraOptions.querySelector('#regional-mode');
const altBattleModeSel = extraOptions.querySelector('#altbattle-mode');
const lblRegionalMode  = extraOptions.querySelector('#lblRegionalMode');
const lblAltBattleMode = extraOptions.querySelector('#lblAltBattleMode');

const gmaxModeSel = extraOptions.querySelector('#gmax-mode');
const lblGmaxMode = extraOptions.querySelector('#lblGmaxMode');


function updateGenTogglesVisibility() {
  const sel = extraOptions.dataset.selectedGen;
  const isAll = (sel === "ALL");
  const g = isAll ? NaN : parseInt(sel, 10);

  const showRegional  = isAll || (g >= REGIONAL_MIN_GEN);
  const showAltBattle = isAll || ALT_BATTLE_GENS.has(g);
  const showGmax      = isAll || g === 8;
  const allowOnly     = g === 8;

  // show/hide labels
  lblRegionalMode.style.display  = showRegional  ? '' : 'none';
  lblAltBattleMode.style.display = showAltBattle ? '' : 'none';
  lblGmaxMode.style.display      = showGmax ? '' : 'none';

  // guard “only” for G-Max
  const optOnly = gmaxModeSel?.querySelector('option[value="only"]');
  if (optOnly) {
    optOnly.disabled = !allowOnly;
    optOnly.hidden   = !allowOnly;
  }
  if (!allowOnly && gmaxModeSel?.value === 'only') {
    gmaxModeSel.value = 'include';
  }
// whole row on/off
  row.style.display = (showRegional || showAltBattle || showGmax) ? '' : 'none';

  // reset hidden controls to Off so we don’t leak state across gens
  if (!showRegional  && regionalModeSel)  regionalModeSel.value  = 'off';
  if (!showAltBattle && altBattleModeSel) altBattleModeSel.value = 'off';
  if (!showGmax && gmaxModeSel)           gmaxModeSel.value      = 'off';
}

  // Initialize visibility for the default selected gen
  updateGenTogglesVisibility();
}

if (cat === 'starters') {
  // 1) Ensure the switch CSS exists once (very small, ~10 rules)
  if (!document.getElementById('pr-toggle-css')) {
    const style = document.createElement('style');
    style.id = 'pr-toggle-css';
    style.textContent = `
      .pr-toggle{display:inline-flex;align-items:center;gap:10px;cursor:pointer;user-select:none}
      .pr-toggle input{position:absolute;opacity:0;width:0;height:0}
      .pr-switch{width:44px;height:24px;border-radius:9999px;background:#e5e7eb;position:relative;transition:background .18s ease}
      .pr-switch::after{content:"";position:absolute;top:3px;left:3px;width:18px;height:18px;border-radius:9999px;background:#fff;
        box-shadow:0 1px 2px rgba(0,0,0,.25);transition:transform .18s ease}
      .pr-toggle input:checked + .pr-switch{background:#2563eb}
      .pr-toggle input:checked + .pr-switch::after{transform:translateX(20px)}
      .pr-state{min-width:28px;font-size:.9rem;color:#6b7280}
      .pr-state[data-onoff="off"]::before{content:"Off"}
      .pr-state[data-onoff="on"]::before{content:"On"}
    `;
    document.head.appendChild(style);
  }

  // 2) Render the two switches
  extraOptions.innerHTML = `
    <div class="settings" style="display:flex;gap:20px;align-items:center;justify-content:center;flex-wrap:wrap;margin-top:6px;">
      <label class="pr-toggle">
        <input id="tgPikaEeveeCfg" type="checkbox" role="switch" aria-label="Add Pikachu and Eevee">
        <span class="pr-switch" aria-hidden="true"></span>
        <span>Add Pikachu & Eevee?</span>
        <span class="pr-state" id="tgPikaEeveeState" aria-hidden="true" data-onoff="off"></span>
      </label>

      <label class="pr-toggle">
        <input id="tgStarterLinesCfg" type="checkbox" role="switch" aria-label="Full Starter Line">
        <span class="pr-switch" aria-hidden="true"></span>
        <span>Full Starter Line</span>
        <span class="pr-state" id="tgStarterLinesState" aria-hidden="true" data-onoff="off"></span>
      </label>
    </div>
  `;

  // 3) Hydrate from previous choices (if any)
  const get = k => localStorage.getItem(k) === 'true';
  const elP = extraOptions.querySelector('#tgPikaEeveeCfg');
  const elL = extraOptions.querySelector('#tgStarterLinesCfg');
  const stP = extraOptions.querySelector('#tgPikaEeveeState');
  const stL = extraOptions.querySelector('#tgStarterLinesState');

  elP.checked = get('addPikaEevee');
  elL.checked = get('includeStarterLines');
  stP.dataset.onoff = elP.checked ? 'on' : 'off';
  stL.dataset.onoff = elL.checked ? 'on' : 'off';

  // 4) Live “On/Off” indicator (purely visual for now)
  elP.addEventListener('change', () => { stP.dataset.onoff = elP.checked ? 'on' : 'off'; });
  elL.addEventListener('change', () => { stL.dataset.onoff = elL.checked ? 'on' : 'off'; });
}


if (cat === 'legendaries') {
  extraOptions.innerHTML = `
    <div class="legendary-row" style="margin-bottom:12px;">
      <div class="toggle-row" style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
        <label for="mythicals" style="font-weight:600;">Mythicals:</label>
        <select id="mythicals">
          <option value="none" selected>Excluded</option>
          <option value="include">Included</option>
          <option value="only">Only</option>
        </select>

        <label style="font-weight:600;">Ultra Beasts:
          <select id="ubMode">
            <option value="exclude" selected>Excluded</option>
            <option value="include">Included</option>
          
            <option value="only">Only</option>
          </select>
        </label>
        <label style="font-weight:600;">Forms:
          <select id="formsMode">
            <option value="off">No Forms</option> <!-- Disable all forms -->
            <option value="gmax">+G-Max</option> <!-- Only G-Max forms -->
            <option value="mega">+Mega/Primal</option> <!-- Only Mega and Primal forms -->
            <option value="all">+All Forms</option> <!-- Include all forms (G-Max, Mega, Primal, etc.) -->
          </select>
        </label>
      </div>
    </div>
  `;

  // When "Mythicals = Only", disable Ultra Beasts selector (can’t be “only” both)
const ubSel   = extraOptions.querySelector('#ubMode');
const mythSel = extraOptions.querySelector('#mythicals');

function syncLegendaryDependencies(changed) {
  const mythMode = mythSel.value || 'none';
  const ubMode   = ubSel.value   || 'exclude';

  // If Mythicals = Only → lock UBs to Excluded and disable the selector
  if (mythMode === 'only') {
    ubSel.disabled = true;
    ubSel.value = 'exclude';
    mythSel.disabled = false; // allow user to switch back
    return;
  }

  // If UBs = Only → lock Mythicals to Excluded and disable the selector
  if (ubMode === 'only') {
    mythSel.disabled = true;
    mythSel.value = 'none';
    ubSel.disabled = false; // allow user to switch back
    return;
  }

  // Otherwise both enabled
  mythSel.disabled = false;
  ubSel.disabled = false;
}

// Wire up both selectors
mythSel.addEventListener('change', () => syncLegendaryDependencies('myth'));
ubSel.addEventListener('change', () => syncLegendaryDependencies('ub'));
syncLegendaryDependencies();
}



if (cat === 'type') {
  extraOptions.innerHTML = `
    <fieldset style="display:flex; gap:16px; align-items:center; flex-wrap:wrap; margin: 6px 0 10px;">
      <legend style="font-weight:600;">Type Mode</legend>
      <label><input type="radio" name="typeMode" id="modeMono" value="mono" checked> Mono Type</label>
      <label><input type="radio" name="typeMode" id="modeDual" value="dual"> Dual Type</label>
    </fieldset>

    <div class="type-pickers" style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
      <label>Type 1:
        <select id="type1"></select>
      </label>
      <label id="type2Wrap" style="display:none;">Type 2:
        <select id="type2"></select>
      </label>
      <label id="strictWrap" style="display:inline-flex; align-items:center; gap:8px; margin-left:12px;">
        <input type="checkbox" id="strictMono">
        <span>Exclude dual‑types (strict mono)</span>
      </label>
    </div>
  `;

  const type1 = extraOptions.querySelector('#type1');
  const type2 = extraOptions.querySelector('#type2');

  [type1, type2].forEach(sel => {
    sel.innerHTML = `<option value="">Any</option>` + TYPES.map(t => `<option value="${t}">${t}</option>`).join('');
  });

  const modeMono   = extraOptions.querySelector('#modeMono');
  const modeDual   = extraOptions.querySelector('#modeDual');
  const type2Wrap  = extraOptions.querySelector('#type2Wrap');
  const strictWrap = extraOptions.querySelector('#strictWrap');

  function syncTypePickers() {
    const isDual = modeDual.checked;
    type2Wrap.style.display  = isDual ? 'inline-block' : 'none';
    strictWrap.style.display = isDual ? 'none' : 'inline-flex'; // only show strict for Mono
  }
  modeMono.addEventListener('change', syncTypePickers);
  modeDual.addEventListener('change', syncTypePickers);
  syncTypePickers();
}



  });

  // Helper for reading dynamic els
  function getEl(id){ return extraOptions.querySelector('#' + id); }

  // Start Ranking
document.getElementById('btnStartRanking').addEventListener('click', () => {
  const category = categorySelect.value || 'starters';

  const config = {
    includeShinies: !!includeShiniesCheckbox.checked,
    shinyOnly: !!shinyOnlyCheckbox.checked,
    category,
    filters: {}
  };

   if (category === 'generation') {
 const gen = extraOptions.dataset.selectedGen;
  if (!gen) { alert('Choose a generation.'); return; }
  config.filters.generation = (gen === "ALL") ? "ALL" : parseInt(gen, 10);

const regionalModeSel  = extraOptions.querySelector('#regional-mode');
const altBattleModeSel = extraOptions.querySelector('#altbattle-mode');
const gmaxModeSel      = extraOptions.querySelector('#gmax-mode');

const regionalMode  = regionalModeSel ? regionalModeSel.value  : 'off';     // 'off' | 'include'
const altBattleMode = altBattleModeSel ? altBattleModeSel.value : 'off';    // 'off' | 'include'
const gmaxMode      = gmaxModeSel ? gmaxModeSel.value : 'off';              // 'off' | 'include' | 'only'

config.toggles = {
  regionalMode,
  altBattleMode,
  gmax:     gmaxMode !== 'off',
  gmaxOnly: gmaxMode === 'only',
};


}


if (category === 'starters') {
  config.filters.starters = true;

  // Read our slide toggles if they exist (default to Off if they aren’t on the page)
  const pe = extraOptions.querySelector('#tgPikaEeveeCfg');     // “Add Pikachu & Eevee”
  const fl = extraOptions.querySelector('#tgStarterLinesCfg');  // “Full Starter Line”

  const addPikaEevee        = !!pe?.checked;
  const includeStarterLines  = !!fl?.checked;

  // Persist for the Starters page
  localStorage.setItem('addPikaEevee',       String(addPikaEevee));
  localStorage.setItem('includeStarterLines', String(includeStarterLines));

  // Also mirror into this run’s config (handy if you read rankConfig)
  config.toggles = { addPikaEevee, includeStarterLines };
}

  // ✅ NEW: capture Legendaries selectors → config.toggles
  if (category === 'legendaries') {
    const mythSel  = extraOptions.querySelector('#mythicals');
    const ubSel    = extraOptions.querySelector('#ubMode');
    const formsSel = extraOptions.querySelector('#formsMode');

    config.toggles = {
      mythMode:  mythSel  ? mythSel.value  : 'none',     // 'none' | 'include' | 'only'
      ubsMode:   ubSel    ? ubSel.value    : 'exclude',  // 'exclude' | 'include' | 'only'
      formsMode: formsSel ? formsSel.value : 'off'  // 'off' | 'gmax' | 'mega' | 'all'
    };
  }

if (category === 'type') {
  const isDual = !!getEl('modeDual')?.checked;
  const t1 = getEl('type1')?.value || '';
  const t2 = getEl('type2')?.value || '';
  const strictMono = !!getEl('strictMono')?.checked;

  if (!isDual) {
    if (!t1) { alert('Choose Type 1 for Mono.'); return; }
    config.filters.type = { mode: 'mono', types: [t1], strictMono };
  } else {
    if (!t1 || !t2) { alert('Choose both Type 1 and Type 2 for Dual.'); return; }
    if (t1 === t2) { alert('Type 1 and Type 2 must be different for Dual.'); return; }
    const types = [t1, t2].sort(); // normalize so Fire/Flying == Flying/Fire
    config.filters.type = { mode: 'dual', types };
  }
}


    localStorage.setItem('rankConfig', JSON.stringify(config));
    localStorage.setItem('includeShinies', config.includeShinies);
    localStorage.setItem('shinyOnly', config.shinyOnly);
    localStorage.setItem('category', config.category);

    const dest = (category === 'starters') ? 'starters.html' : 'ranker.html';
    window.location.href = dest;
  });

  /* =========================
     Storage helpers (v1)
     ========================= */

  function loadSavedArray(){
    try { return JSON.parse(localStorage.getItem('savedRankings') || '[]'); }
    catch { return []; }
  }
  function saveSavedArray(arr){
    localStorage.setItem('savedRankings', JSON.stringify(arr));
  }

  function canonicalKey(run){
    return run?.key || run?.id || `${(run?.category||'Unknown')}_${!!run?.includeShinies}_${!!run?.shinyOnly}`;
  }

  function parseWhen(run){
    const s = run?.lastModified || run?.date || new Date().toISOString();
    return new Date(s).getTime();
  }

  function collectAllRankingsFromLocal() {
    const map = {};
    const arr = loadSavedArray();
    for (const r of arr){
      if (!r) continue;
      const id = canonicalKey(r);
      map[id] = r;
    }
    return map;
  }

  function setAllRankingsToLocal(map) {
    const mergedArr = Object.values(map);
    saveSavedArray(mergedArr);
    localStorage.setItem('pokeRankr.rankings', JSON.stringify(map));
  }

  function buildExportPayload() {
    const arr = loadSavedArray();
    return {
      app: APP_NAME,
      appVersion: APP_VERSION,
      schemaVersion: SCHEMA_VERSION,
      exportedAt: new Date().toISOString(),
      rankings: arr
    };
  }

  function downloadRankings() {
    const data = buildExportPayload();
    if (!data.rankings.length) {
      alert('No saved rankings found to export.');
      return;
    }
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `pokeRankr-backup-${ts}.json`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }

  function isValidExport(obj) {
    return obj && typeof obj === 'object' &&
           obj.app === APP_NAME &&
           Array.isArray(obj.rankings);
  }

  // Merges imported rankings into existing using "Keep Newest" rule.
  function mergeKeepNewest(existingMap, importedArr){
    const out = { ...existingMap };
    for (const r of importedArr){
      if (!r || typeof r !== 'object') continue;
      const id = canonicalKey(r);
      const cur = out[id];
      if (!cur){
        out[id] = r;
        continue;
      }
      const curWhen = parseWhen(cur);
      const newWhen = parseWhen(r);
      if (newWhen > curWhen){
        out[id] = r;
      }
    }
    return out;
  }

  async function handleFileUpload(file) {
    try {
      const text = await file.text();
      const data = JSON.parse(text);

      if (!isValidExport(data)) {
        alert('Invalid file format. Please select a PokéRankr backup JSON.');
        return;
      }

      const existingMap = collectAllRankingsFromLocal();
      const merged = mergeKeepNewest(existingMap, data.rankings);
      setAllRankingsToLocal(merged);

      const before = Object.keys(existingMap).length;
      const after  = Object.keys(merged).length;
      const delta  = after - before;
      alert(`Import complete.\nUpdated or added ${Math.max(0, delta)} item(s) using "Keep Newest".`);

      if (after && confirm('Open Saved Rankings now?')) {
        window.location.href = 'saved.html';
      }
    } catch (err) {
      console.error(err);
      alert('Could not import that file.');
    }
  }

  // === Hook up Download / Upload buttons ===
  document.getElementById('btnDownload').addEventListener('click', downloadRankings);

  /* =========================
     Save Slots (global: 3)
     ========================= */
  const SAVE_SLOTS_KEY = 'PR_SAVE_SLOTS_V1';

  function slotsRead() {
    try {
      const arr = JSON.parse(localStorage.getItem(SAVE_SLOTS_KEY) || '[]');
      const out = Array.isArray(arr) ? arr.slice(0, 3) : [];
      while (out.length < 3) out.push(null);
      return out;
    } catch {
      return [null, null, null];
    }
  }
  function slotsWrite(slots) {
    localStorage.setItem(SAVE_SLOTS_KEY, JSON.stringify(slots));
  }
  function anySlotUsed() {
    return slotsRead().some(Boolean);
  }

  (function initManageSavesButton(){
    const btn = document.getElementById('btnManageSaves');
    if (!btn) return;
    if (anySlotUsed()) btn.style.display = '';
    btn.addEventListener('click', openManageSavesModal);
  })();

  function openManageSavesModal() {
    const m = document.getElementById('manageSavesModal');
    if (!m) return;
    m.style.display = 'flex';
    renderManageSlots();
  }
  function closeManageSavesModal() {
    const m = document.getElementById('manageSavesModal');
    if (!m) return;
    m.style.display = 'none';
  }
  document.getElementById('btnCloseManage')?.addEventListener('click', closeManageSavesModal);

 function spriteUrl(id, shiny) {
  return shiny
    ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/${id}.png`
    : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`;
}
  function renderManageSlots() {
    const grid = document.getElementById('manageSlotsGrid');
    const slots = slotsRead();

    grid.innerHTML = slots.map((slot, i) => {
      if (!slot) {
        return `
          <div class="slot-card" data-idx="${i}">
  <div class="slot-body">Empty Slot</div>
  <div class="slot-actions">
    <button class="compact delete-btn" data-action="delete" data-idx="${i}" disabled>
      <span class="button_top">Delete</span>
    </button>
    <button class="compact resume-btn" data-action="resume" data-idx="${i}" disabled>
      <span class="button_top">Resume</span>
    </button>
  </div>
</div>

        `;
      }

      const a = slot.currentMatchup?.a;
      const b = slot.currentMatchup?.b;
      const savedAt = new Date(slot.meta?.savedAt || Date.now()).toLocaleString();
      const title = slot.label || 'Saved Run';
      const hrefHint = slot.type === 'starters' ? 'starters.html' : 'ranker.html';

      // Prefer new post-aware fields if present
let displayLabel = slot?.progress?.displayLabel;
let displayRemaining = slot?.progress?.displayRemaining;

// If not present (old saves), compute manually
if (!displayLabel) {
  const inPost = !!slot?.state?.postMode &&
                 (slot?.state?.post?.phase === 'RU' || slot?.state?.post?.phase === 'THIRD');

  if (inPost) {
    const total = typeof slot?.state?.post?.totalMatches === 'number'
      ? slot.state.post.totalMatches : 0;
    const done  = typeof slot?.state?.post?.doneMatches === 'number'
      ? slot.state.post.doneMatches : 0;
    const left  = Math.max(0, total - done - 1);

    displayLabel = (slot.state.post.phase === 'RU'
      ? 'Runner-up bracket — ' : 'Third-place bracket — ')
      + `${left} matchups remaining`;
    displayRemaining = left;
  } else {
    const rem = (slot?.progress && typeof slot.progress.remaining === 'number')
      ? slot.progress.remaining
      : (Array.isArray(slot?.state?.remaining) ? slot.state.remaining.length : null);
    if (rem !== null && rem !== undefined) {
      displayLabel = `${rem} matchups remaining`;
      displayRemaining = rem;
    }
  }
}

const remainingLine = displayLabel
  ? `<div style="font-size:.8rem; color:#374151; margin:6px 0 10px; text-align:center;">${displayLabel}</div>`
  : '';
return `
  <div class="slot-card" data-idx="${i}">
    <div class="slot-body" style="flex-direction:column; gap:4px;">
      <div style="display:flex; align-items:center; gap:8px; justify-content:center; min-height:120px;">
        ${a ? `<img src="${spriteUrl(a.id, a.shiny)}" alt="${a.name}" width="72" height="72">` : ''}
        <span style="font-weight:700;">VS</span>
        ${b ? `<img src="${spriteUrl(b.id, b.shiny)}" alt="${b.name}" width="72" height="72">` : ''}
      </div>
      <div style="font-size:.95rem; color:#111827; font-weight:600;">${title}</div>
      <div style="font-size:.8rem; color:#6b7280;">Saved ${savedAt}</div>
      ${remainingLine}
    </div>
    <div class="slot-actions">
      <button class="compact delete-btn" data-action="delete" data-idx="${i}">
        <span class="button_top">Delete</span>
      </button>
      <button class="compact resume-btn" data-action="resume" data-idx="${i}" data-href="${hrefHint}">
        <span class="button_top">Resume</span>
      </button>
    </div>
  </div>
`;


    }).join('');

    grid.onclick = (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const idx = +btn.dataset.idx;
      const action = btn.dataset.action;
      const slotsArr = slotsRead();

      if (action === 'delete') {
        if (slotsArr[idx] && !confirm('Delete this save slot?')) return;
        slotsArr[idx] = null;
        slotsWrite(slotsArr);
        renderManageSlots();
        if (!anySlotUsed()) document.getElementById('btnManageSaves').style.display = 'none';
        return;
      }

      if (action === 'resume') {
        const s = slotsArr[idx];
        if (!s) return;
        localStorage.setItem('PR_PENDING_RESUME_SLOT', String(idx));
        window.location.href = (s.type === 'starters') ? 'starters.html' : 'ranker.html';
      }
    };
  }

  function exportSaveSlots() {
    const data = {
      app: APP_NAME,
      appVersion: APP_VERSION,
      schemaVersion: SCHEMA_VERSION,
      exportedAt: new Date().toISOString(),
      saveSlots: slotsRead()
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `pokeRankr-saveSlots-${ts}.json`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(a.href), 1500);
  }
  function isValidSaveSlots(obj) {
    return obj && typeof obj === 'object' && obj.app === APP_NAME && Array.isArray(obj.saveSlots);
  }
  document.getElementById('btnExportSaves')?.addEventListener('click', exportSaveSlots);

  const importSavesInput = document.getElementById('importSavesInput');
  document.getElementById('btnImportSaves')?.addEventListener('click', () => importSavesInput.click());
  importSavesInput?.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      if (!isValidSaveSlots(data)) {
        alert('Invalid save-slots file.');
        importSavesInput.value = '';
        return;
      }
      slotsWrite((data.saveSlots || []).slice(0,3));
      renderManageSlots();
      document.getElementById('btnManageSaves').style.display = anySlotUsed() ? '' : 'none';
      alert('Save slots imported.');
    } catch (err) {
      console.error(err);
      alert('Could not import that file.');
    } finally {
      importSavesInput.value = '';
    }
  });

const uploadInput = document.getElementById('uploadInput');
const btnUpload = document.getElementById('btnUpload');

if (btnUpload && uploadInput) {
  btnUpload.addEventListener('click', () => uploadInput.click());

  uploadInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    handleFileUpload(file);
    uploadInput.value = '';
  });
} else {
  console.warn('Upload UI is missing: #btnUpload or #uploadInput not found.');
}
</script>
<script>
// Ensure all buttons have the .button_top styling + wire feedback modal
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('button:not(:has(.button_top))').forEach(btn => {
    const span = document.createElement('span');
    span.className = 'button_top';
    while (btn.firstChild) span.appendChild(btn.firstChild);
    btn.appendChild(span);
  });

  // === Feedback modal wiring ===
  const btnOpen  = document.getElementById('btnFeedback');
  const modal    = document.getElementById('feedbackModal');
  const closeX   = document.getElementById('fbClose');
  const cancel   = document.getElementById('feedbackCancel');
  const message  = document.getElementById('fbMessage');
  const form     = document.getElementById('feedbackForm');

  function openModal() {
    if (!modal) return;
    modal.style.display = 'flex';
    setTimeout(() => message?.focus(), 0);
  }
  function closeModal() {
    if (!modal) return;
    modal.style.display = 'none';
  }

  btnOpen?.addEventListener('click', openModal);
  closeX?.addEventListener('click', closeModal);
  cancel?.addEventListener('click', closeModal);

  // Close on click outside the dialog
  modal?.addEventListener('click', (e) => {
    if (e.target === modal) closeModal();
  });

  // Close on Esc
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeModal();
  });

  // === NEW: AJAX submit to Formspree (no page reload) ===
  form?.addEventListener('submit', async (e) => {
    e.preventDefault();
    const endpoint = form.getAttribute('action');
    const data = new FormData(form);

    // Optional: include page context
    data.append('page', 'PokeRankr Home');

    try {
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Accept': 'application/json' },
        body: data
      });

      if (res.ok) {
        // success UX
        form.reset();
        closeModal();
        alert('Thanks! Your feedback was sent.'); // swap for a toast later if you want
      } else {
        alert('Could not send feedback. Please try again.');
      }
    } catch (err) {
      alert('Network error. Please try again.');
    }
  });
});

// === Badge Notification System ===
function updateBadgeNotification() {
  const notification = document.getElementById('badgeNotification');
  if (!notification) return;
  
  // Get achievements data
  const achievements = JSON.parse(localStorage.getItem('PR_ACHIEVEMENTS') || '{}');
  
  // Count new badges that haven't been viewed this session
  let newCount = 0;
  Object.keys(achievements).forEach(badgeId => {
    if (achievements[badgeId]?.isNew && !sessionStorage.getItem(`badge_${badgeId}_viewed`)) {
      newCount++;
    }
  });
  
  // Update notification bubble
  if (newCount > 0) {
    notification.textContent = newCount;
    notification.style.display = 'flex';
  } else {
    notification.style.display = 'none';
  }
}

// Check for new badges - using the correct logic from badges.html
function checkForNewBadges() {
  const achievements = JSON.parse(localStorage.getItem('PR_ACHIEVEMENTS') || '{}');
  const completions = JSON.parse(localStorage.getItem('PR_COMPLETIONS') || '[]');
  let hasNewBadge = false;
  
  // Use the SAME logic as badges.html
  const totalRankings = completions.length;
  
  // Boulder Badge - First ranking
  if (totalRankings >= 1 && !achievements.boulder?.unlocked) {
    achievements.boulder = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Cascade Badge - 5 rankings  
  if (totalRankings >= 5 && !achievements.cascade?.unlocked) {
    achievements.cascade = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Thunder Badge - 10 rankings
  if (totalRankings >= 10 && !achievements.thunder?.unlocked) {
    achievements.thunder = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Rainbow Badge - One ranking in each main category
  const categories = new Set(completions.map(c => c.category));
  if (categories.has('generation') && categories.has('starters') && 
      categories.has('legendaries') && categories.has('type') && !achievements.rainbow?.unlocked) {
    achievements.rainbow = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Soul Badge - Gen 1 Pokemon wins (but NOT in Gen 1-only category) - FIXED
  const hasGen1Winner = completions.some(c => 
    c.championId && c.championId <= 151 && 
    !(c.category === 'generation' && c.subcategory === 'generation-1')
  );
  if (hasGen1Winner && !achievements.soul?.unlocked) {
    achievements.soul = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Marsh Badge - Each Pokemon (#1-1025) must appear in at least one ranking
  const allSeenPokemonIds = new Set();
  completions.forEach(completion => {
    if (Array.isArray(completion.pokemonIds)) {
      completion.pokemonIds.forEach(id => allSeenPokemonIds.add(id));
    }
  });

  const hasAllPokemon = allSeenPokemonIds.size >= 1025;
  let foundAllDexNumbers = false;
  if (hasAllPokemon) {
    foundAllDexNumbers = true;
    for (let i = 1; i <= 1025; i++) {
      if (!allSeenPokemonIds.has(i)) {
        foundAllDexNumbers = false;
        break;
      }
    }
  }

  if (foundAllDexNumbers && !achievements.marsh?.unlocked) {
    achievements.marsh = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Volcano Badge - Shiny winner (not in shiny-only mode) - FIXED VERSION
  const shinyWinnerInMixed = completions.some(c => {
    if (!c.championShiny) return false;
    if (!c.includeShinies) return false;
    if (c.shinyOnly === true) return false;
    return true;
  });
  if (shinyWinnerInMixed && !achievements.volcano?.unlocked) {
    achievements.volcano = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  // Earth Badge - Complete comprehensive set
  const subcategories = new Set(completions.map(c => c.subcategory));
  const subcategoriesLc = new Set(
    [...subcategories].filter(Boolean).map(s => String(s).toLowerCase())
  );

  const TYPE_SLUGS = [
    'normal','fire','water','grass','electric','ice','fighting','poison','ground','flying',
    'psychic','bug','rock','ghost','dragon','dark','steel','fairy'
  ];

  const hasAllGens = ['1','2','3','4','5','6','7','8','9','all'].every(g =>
    subcategoriesLc.has(`generation-${g}`)
  );

  const hasStarters = categories.has('starters');

  const hasLegendaries = (() => {
    const ALL_IN_ONE = ['legendaries-all', 'legendaries-complete', 'legendaries-all-in-one'];
    const LEGENDARY_ONLY = ['legendaries-base', 'legendaries-only', 'legendaries'];
    const MYTHICALS     = ['legendaries-mythicals', 'mythicals', 'legendaries-mythical'];
    const ULTRA_BEASTS  = ['legendaries-ultra-beasts', 'legendaries-ultrabeasts', 'ultra-beasts', 'ultrabeasts'];

    const anyOf = arr => arr.some(s => subcategoriesLc.has(s));

    if (anyOf(ALL_IN_ONE)) return true;
    return anyOf(LEGENDARY_ONLY) && anyOf(MYTHICALS) && anyOf(ULTRA_BEASTS);
  })();

  const hasTypes = TYPE_SLUGS.every(t => subcategoriesLc.has(`type-${t}`));

  if (hasAllGens && hasStarters && hasLegendaries && hasTypes && !achievements.earth?.unlocked) {
    achievements.earth = { unlocked: true, date: new Date().toISOString(), isNew: true };
    hasNewBadge = true;
  }
  
  if (hasNewBadge) {
    localStorage.setItem('PR_ACHIEVEMENTS', JSON.stringify(achievements));
  }
  
  return hasNewBadge;
}

// Update notification on page load
document.addEventListener('DOMContentLoaded', () => {
  checkForNewBadges();
  updateBadgeNotification();
});

// Also update when returning from other pages  
window.addEventListener('pageshow', () => {
  checkForNewBadges();  // Add this line!
  updateBadgeNotification();
});
</script>
<!-- Auth Modal -->
<div id="authModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:1000; align-items:center; justify-content:center;">
  <div style="background:white; border-radius:20px; padding:30px; max-width:400px; width:90%; text-align:center;">
    <h2>Join PokeRankr</h2>
    
    <!-- OAuth Buttons -->
    <button id="discordLoginBtn" style="width:100%; margin:10px 0; background:#5865F2;" class="menu-button">
      <span class="button_top">Continue with Discord</span>
    </button>
    
    <div style="margin: 20px 0; color: #666;">or</div>
    
    <!-- Email Form -->
    <div id="emailForm">
      <input type="email" id="emailInput" placeholder="Email" style="width:100%; padding:12px; margin:8px 0; border:2px solid #d2deff; border-radius:8px; box-sizing:border-box;">
      <input type="password" id="passwordInput" placeholder="Password" style="width:100%; padding:12px; margin:8px 0; border:2px solid #d2deff; border-radius:8px; box-sizing:border-box;">
      <button id="emailSignUpBtn" style="width:100%; margin:10px 0;" class="menu-button">
        <span class="button_top">Sign Up with Email</span>
      </button>
      <button id="emailLoginBtn" style="width:100%; margin:10px 0;" class="menu-button alt">
        <span class="button_top">Login with Email</span>
      </button>
    </div>
    
    <button onclick="closeAuthModal()" style="margin-top:20px;" class="menu-button alt">
      <span class="button_top">Cancel</span>
    </button>
  </div>
</div>
</body>
</html>