<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="UTF-8" />
  <title>PokeRankr - Badge Case</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
  <style>
/* Prevent horizontal scroll on mobile */
html, body {
  overflow-x: hidden;
  width: 100%;
}

.badge-case-container {
  max-width: 100%;
  overflow-x: hidden;
}


    /* Badge Case Specific Styles */
  .badge-case-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px 20px 60px 20px;  /* Extra bottom padding for button */
}
    
    .badge-case {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 24px;
      padding: 30px;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.12);
      border: 3px solid rgba(210, 222, 255, 0.6);
      margin-top: 20px;
    }
    
    .badges-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 30px;
      margin: 30px 0;
    }
    
    .badge-slot {
      position: relative;
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    
    .badge-slot:hover {
      transform: scale(1.05);
    }
    
    .badge-image {
  width: 100%;
  height: 100%;
  max-width: 100px;  /* Add max width constraint */
  max-height: 100px; /* Add max height constraint */
  object-fit: contain;
  transition: all 0.3s ease;
  filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
}
    
    .badge-image.locked {
      filter: brightness(0.3) contrast(1.2);
      opacity: 0.6;
    }
    
    .badge-name {
  position: absolute;
  bottom: -25px;
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--text);
  text-align: center;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 0 5px;
}
    
    .badge-new {
      position: absolute;
      top: -8px;
      right: -8px;
      background: #ff3b30;
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: bold;
      animation: bounce 1s infinite;
      z-index: 10;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
    }
    
    @keyframes badgeUnlock {
      0% { 
        transform: scale(0) rotate(0deg);
        opacity: 0;
      }
      50% {
        transform: scale(1.2) rotate(180deg);
        opacity: 1;
      }
      100% {
        transform: scale(1) rotate(360deg);
        opacity: 1;
      }
    }
    
    .badge-unlocking {
      animation: badgeUnlock 0.8s ease-out;
    }
    
    .badge-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin: 20px 0;
      padding: 20px;
      background: var(--panel-soft);
      border-radius: 12px;
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: var(--primary);
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: var(--text-soft);
    }
    
    /* Badge Details Modal */
    .badge-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
    }
    
    .badge-modal-content {
      background: white;
      border-radius: 20px;
      padding: 30px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    .badge-modal-image {
      width: 120px;
      height: 120px;
      margin: 0 auto 20px;
    }
    
    .badge-modal-title {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--text);
      margin-bottom: 10px;
    }
    
    .badge-modal-description {
      color: var(--text-soft);
      margin-bottom: 15px;
      line-height: 1.5;
    }
    
    .badge-modal-requirement {
      background: var(--panel-soft);
      padding: 10px 15px;
      border-radius: 10px;
      font-size: 0.9rem;
      margin-bottom: 20px;
    }
    
    .badge-modal-date {
  font-size: 0.85rem;
  color: var(--accent);
  font-weight: 600;
  margin: 20px 0 25px 0;  /* Added proper spacing */
}
    
/* Mobile badge layout fix */
@media (max-width: 480px) {
  .badges-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 15px 10px;  /* vertical and horizontal gap */
    padding: 0;
    margin-bottom: 20px;
  }
  
  .badge-slot {
    position: relative;
    width: 100%;
    padding-bottom: 30px;  /* Space for the name below */
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .badge-image {
    width: 100px;
    height: 100px;
    max-width: 100%;
  }
  
  .badge-name {
    position: static;  /* Not absolute anymore */
    margin-top: 8px;
    font-size: 0.75rem;
    width: 100%;
    text-align: center;
    padding: 0 5px;
  }
  
  .badge-case {
    padding: 20px 15px 40px 15px;  /* Bottom padding for content */
  }
  
  .badge-case-container {
    padding: 20px 10px 20px 10px;
    overflow: visible;  /* Allow badge names to show */
  }
  
  /* Stats smaller on mobile */
  .badge-stats {
    gap: 8px;
    padding: 12px;
  }
  
  .stat-value {
    font-size: 1.3rem;
  }
  
  .stat-label {
    font-size: 0.75rem;
  }
  
  /* Ensure button has space */
  .button-row {
    margin-top: 30px !important;
    padding: 0 10px;
  }
}
  </style>
<!-- Supabase Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
  <!-- User Header (shows when logged in) -->
<div id="userHeader" style="display:none;">
  <style>
    #userHeader {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 10px 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      border: 2px solid #d2deff;
    }
    
    /* Mobile: Move to bottom */
    @media (max-width: 768px) {
      #userHeader {
        top: auto;
        bottom: 10px;
        right: 10px;
        left: 10px;
        max-width: fit-content;
        margin: 0 auto;
      }
    }
    
    /* Hide on non-index pages for mobile */
    @media (max-width: 768px) {
      body:not(.index-page) #userHeader {
        display: none !important;
      }
    }
  </style>
  <div style="display:flex; align-items:center; gap:12px;">
    <div style="width:48px; height:48px; overflow:hidden; position:relative; flex-shrink:0;">
      <img id="headerSprite" src="" alt="Trainer" style="width:80px; height:80px; min-width:80px; min-height:80px; max-width:80px; max-height:80px; image-rendering:pixelated; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);">
    </div>
    <span id="headerUsername" style="font-weight:600; color:var(--text);"></span>
    <button id="btnLogout" class="compact" style="--button_color:#ff3b30; --button_outline_color:#ff3b30;">
      <span class="button_top" style="color:white; padding:0.3em 0.8em; font-size:12px;">Log Out</span>
    </button>
  </div>
</div>
  <div class="badge-case-container">
    <h1>Badge Case</h1>
    
    <!-- Stats Overview -->
    <div class="badge-stats">
      <div class="stat-item">
        <div class="stat-value" id="badgesEarned">0</div>
        <div class="stat-label">Badges Earned</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="totalRankings">0</div>
        <div class="stat-label">Total Rankings</div>
      </div>
      <div class="stat-item">
        <div class="stat-value" id="completion">0%</div>
        <div class="stat-label">Completion</div>
      </div>
    </div>
    
    <!-- Badge Case -->
    <div class="badge-case">
      <div class="badges-grid" id="badgesGrid">
        <!-- Badges will be populated here -->
      </div>
    </div>
    
    <!-- Back Button -->
    <div class="button-row" style="margin-top: 30px;">
      <button onclick="window.location.href='index.html'">
        <span class="button_top">Back to Menu</span>
      </button>
    </div>
  </div>
  
  <!-- Badge Details Modal -->
  <div id="badgeModal" class="badge-modal">
    <div class="badge-modal-content">
      <img id="modalBadgeImage" class="badge-modal-image" src="" alt="">
      <h2 id="modalBadgeName" class="badge-modal-title"></h2>
      <p id="modalBadgeDescription" class="badge-modal-description"></p>
      <div id="modalBadgeRequirement" class="badge-modal-requirement"></div>
      <div id="modalBadgeDate" class="badge-modal-date"></div>
      <button onclick="closeBadgeModal()">
        <span class="button_top">Close</span>
      </button>
    </div>
  </div>

  <script>
    // Badge definitions
    const BADGES = [
      {
        id: 'boulder',
        name: 'Boulder Badge',
        description: 'Your first step into the world of Pokemon ranking!',
        requirement: 'Complete your first ranking',
        mysteryText: '???',
        image: 'assets/achievements/boulder-badge.png',
        silhouette: 'assets/achievements/boulder-silhouette.png'
      },
      {
        id: 'cascade',
        name: 'Cascade Badge',
        description: 'Getting into the flow of ranking Pokemon!',
        requirement: 'Complete 5 rankings',
        mysteryText: '???',
        image: 'assets/achievements/cascade-badge.png',
        silhouette: 'assets/achievements/cascade-silhouette.png'
      },
      {
        id: 'thunder',
        name: 'Thunder Badge',
        description: 'Electrifying dedication to ranking!',
        requirement: 'Complete 10 rankings',
        mysteryText: '???',
        image: 'assets/achievements/thunder-badge.png',
        silhouette: 'assets/achievements/thunder-silhouette.png'
      },
      {
        id: 'rainbow',
        name: 'Rainbow Badge',
        description: 'A colorful collection of rankings!',
        requirement: 'Complete one ranking in each category!',
        mysteryText: '???',
        image: 'assets/achievements/rainbow-badge.png',
        silhouette: 'assets/achievements/rainbow-silhouette.png'
      },
      {
        id: 'soul',
        name: 'Soul Badge',
        description: 'Old School Cool',
        requirement: 'Have a Gen 1 Pokemon win a ranking',
        mysteryText: '???',
        image: 'assets/achievements/soul-badge.png',
        silhouette: 'assets/achievements/soul-silhouette.png'
      },
      {
        id: 'marsh',
        name: 'Marsh Badge',
        description: 'Gotta rank \'em all!',
        requirement: 'Rank all 1025 Pokemon across all modes',
        mysteryText: '???',
        image: 'assets/achievements/marsh-badge.png',
        silhouette: 'assets/achievements/marsh-silhouette.png'
      },
      {
        id: 'volcano',
        name: 'Volcano Badge',
        description: 'Shiny Charm!',
        requirement: 'Have a shiny Pokemon win (excl. Shiny Only Mode)',
        mysteryText: '???',
        image: 'assets/achievements/volcano-badge.png',
        silhouette: 'assets/achievements/volcano-silhouette.png'
      },
      {
        id: 'earth',
        name: 'Earth Badge',
        description: 'You are the Dan of PokeRankr!',
        requirement: 'Complete every type of ranking available',
        mysteryText: '???',
        image: 'assets/achievements/earth-badge.png',
        silhouette: 'assets/achievements/earth-silhouette.png'
      }
    ];
    
    // Load achievement data
    function loadAchievements() {
      return JSON.parse(localStorage.getItem('PR_ACHIEVEMENTS') || '{}');
    }
    
    // Save achievement data
    function saveAchievements(data) {
      localStorage.setItem('PR_ACHIEVEMENTS', JSON.stringify(data));
    }

    // Auto-sync if logged in
if (window.PokeRankrAuth && window.PokeRankrAuth.isLoggedIn()) {
  setTimeout(() => {
    window.PokeRankrSync.syncLocalToCloud();
  }, 500);
}

    // Validate and fix incorrectly awarded badges
function validateExistingBadges() {
  const achievements = loadAchievements();
  const completions = JSON.parse(localStorage.getItem('PR_COMPLETIONS') || '[]');
  let correctionsMade = false;
  
  // Validate Volcano Badge - remove if incorrectly awarded
  if (achievements.volcano?.unlocked) {
    const hasValidShinyWin = completions.some(c => {
      return c.championShiny && c.includeShinies && c.shinyOnly !== true;
    });
    
    if (!hasValidShinyWin) {
      delete achievements.volcano;
      correctionsMade = true;
      console.log("Removed incorrectly awarded Volcano Badge");
    }
  }
  
  if (correctionsMade) {
    saveAchievements(achievements);
  }
}
    
    // Check and unlock achievements
    function checkAchievements() {
  const achievements = loadAchievements();
  const completions = JSON.parse(localStorage.getItem('PR_COMPLETIONS') || '[]');
  let newUnlocks = [];
  
  // Basic completion counts
  const totalRankings = completions.length;
  
  // Boulder Badge - First ranking
  if (totalRankings >= 1 && !achievements.boulder) {
    achievements.boulder = { unlocked: true, date: new Date().toISOString(), isNew: true };
    newUnlocks.push('boulder');
  }
  
  // Cascade Badge - 5 rankings
  if (totalRankings >= 5 && !achievements.cascade) {
    achievements.cascade = { unlocked: true, date: new Date().toISOString(), isNew: true };
    newUnlocks.push('cascade');
  }
  
  // Thunder Badge - 10 rankings
  if (totalRankings >= 10 && !achievements.thunder) {
    achievements.thunder = { unlocked: true, date: new Date().toISOString(), isNew: true };
    newUnlocks.push('thunder');
  }
  
  // Rainbow Badge - One ranking in each main category
  const categories = new Set(completions.map(c => c.category));
  if (categories.has('generation') && categories.has('starters') && 
      categories.has('legendaries') && categories.has('type') && !achievements.rainbow) {
    achievements.rainbow = { unlocked: true, date: new Date().toISOString(), isNew: true };
    newUnlocks.push('rainbow');
  }
  
// Soul Badge - Gen 1 Pokemon wins (but NOT in Gen 1-only category)
const hasGen1Winner = completions.some(c => 
  c.championId && c.championId <= 151 && 
  !(c.category === 'generation' && c.subcategory === 'generation-1')
);
if (hasGen1Winner && !achievements.soul) {
  achievements.soul = { unlocked: true, date: new Date().toISOString(), isNew: true };
  newUnlocks.push('soul');
}
  
// Marsh Badge - Each Pokemon (#1-1025) must appear in at least one ranking
const allSeenPokemonIds = new Set();
completions.forEach(completion => {
  if (Array.isArray(completion.pokemonIds)) {
    // New format: use the pokemonIds array
    completion.pokemonIds.forEach(id => allSeenPokemonIds.add(id));
  }
  // Note: We intentionally don't try to reconstruct from old data
  // Users will need new completions to unlock the Marsh Badge
});

// Check if we have all Pokemon #1-1025
const hasAllPokemon = allSeenPokemonIds.size >= 1025;
let foundAllDexNumbers = false;
if (hasAllPokemon) {
  // Double-check: make sure we actually have 1, 2, 3, ..., 1025
  foundAllDexNumbers = true;
  for (let i = 1; i <= 1025; i++) {
    if (!allSeenPokemonIds.has(i)) {
      foundAllDexNumbers = false;
      break;
    }
  }
}

if (foundAllDexNumbers && !achievements.marsh) {
  achievements.marsh = { unlocked: true, date: new Date().toISOString(), isNew: true };
  newUnlocks.push('marsh');
}
  
// Volcano Badge - Shiny winner (not in shiny-only mode)
// Find completions with shiny champions
const shinyCompletions = completions.filter(c => c.championShiny);
console.log("Completions with shiny champions:", shinyCompletions);

// Look at the exact structure of shiny completions
shinyCompletions.forEach((completion, index) => {
  console.log(`Shiny completion ${index}:`, {
    championShiny: completion.championShiny,
    includeShinies: completion.includeShinies,
    shinyOnly: completion.shinyOnly,
    category: completion.category,
    subcategory: completion.subcategory
  });
});

const shinyWinnerInMixed = completions.some(c => {
  // Must have a shiny champion
  if (!c.championShiny) return false;
  
  // Must include shinies
  if (!c.includeShinies) return false;
  
  // Must NOT be shiny-only mode (this is the key part!)
  if (c.shinyOnly === true) return false;
  
  return true;
});

console.log("Should unlock volcano badge:", shinyWinnerInMixed);

if (shinyWinnerInMixed && !achievements.volcano) {
  achievements.volcano = { unlocked: true, date: new Date().toISOString(), isNew: true };
  newUnlocks.push('volcano');
}
  
// Earth Badge - Complete comprehensive set
const subcategories = new Set(completions.map(c => c.subcategory));

// Lowercased view of subcategories for robust matching
const subcategoriesLc = new Set(
  [...subcategories].filter(Boolean).map(s => String(s).toLowerCase())
);

// Full list of the 18 types we require
const TYPE_SLUGS = [
  'normal','fire','water','grass','electric','ice','fighting','poison','ground','flying',
  'psychic','bug','rock','ghost','dragon','dark','steel','fairy'
];

// Gens
const hasAllGens = ['1','2','3','4','5','6','7','8','9','all'].every(g =>
  subcategoriesLc.has(`generation-${g}`)
);


// Uses the categories Set you already created above for Rainbow
const hasStarters = categories.has('starters');

// Legendaries: either one "all-in-one" run OR separate runs for each group
const hasLegendaries = (() => {
  // Accept any of these as an "all-in-one" completion
  const ALL_IN_ONE = ['legendaries-all', 'legendaries-complete', 'legendaries-all-in-one'];

  // Accept these as the three separate buckets
  const LEGENDARY_ONLY = ['legendaries-base', 'legendaries-only', 'legendaries'];
  const MYTHICALS     = ['legendaries-mythicals', 'mythicals', 'legendaries-mythical'];
  const ULTRA_BEASTS  = ['legendaries-ultra-beasts', 'legendaries-ultrabeasts', 'ultra-beasts', 'ultrabeasts'];

  const anyOf = arr => arr.some(s => subcategoriesLc.has(s));

  // If an all-in-one run exists, we’re done
  if (anyOf(ALL_IN_ONE)) return true;

  // Otherwise require all three separate completions
  return anyOf(LEGENDARY_ONLY) && anyOf(MYTHICALS) && anyOf(ULTRA_BEASTS);
})();

// Require ALL 18 types (type-fire, type-water, …)
const hasTypes = TYPE_SLUGS.every(t => subcategoriesLc.has(`type-${t}`));

if (hasAllGens && hasStarters && hasLegendaries && hasTypes && !achievements.earth) {
  achievements.earth = { unlocked: true, date: new Date().toISOString(), isNew: true };
  newUnlocks.push('earth');
}

  
  if (newUnlocks.length > 0) {
    saveAchievements(achievements);
  }
  
  return newUnlocks;
}
    
    // Get player statistics
   function getStats() {
  const completions = JSON.parse(localStorage.getItem('PR_COMPLETIONS') || '[]');
  const categories = new Set();
  let totalPokemonRanked = 0;
  
  completions.forEach(completion => {
    if (completion.category) categories.add(completion.category);
    if (completion.pokemonCount) totalPokemonRanked += completion.pokemonCount;
  });
  
  return {
    totalRankings: completions.length,  // Use completions, not saved
    uniqueCategories: categories.size,
    totalPokemonRanked
  };
}
    // Render badges
    function renderBadges() {
      const achievements = loadAchievements();
      const grid = document.getElementById('badgesGrid');
      const stats = getStats();
      
      // Clear any "new" flags that are older than this session
      Object.keys(achievements).forEach(key => {
        if (achievements[key].isNew && !sessionStorage.getItem(`badge_${key}_seen`)) {
          sessionStorage.setItem(`badge_${key}_seen`, 'true');
        }
      });
      
      grid.innerHTML = BADGES.map(badge => {
        const achievement = achievements[badge.id];
        const isUnlocked = achievement?.unlocked;
        const isNew = achievement?.isNew && !sessionStorage.getItem(`badge_${badge.id}_viewed`);
        
        return `
          <div class="badge-slot" onclick="showBadgeDetails('${badge.id}')">
            <img 
              class="badge-image ${!isUnlocked ? 'locked' : ''}" 
              src="${isUnlocked ? badge.image : badge.silhouette}"
              alt="${badge.name}"
            >
            <div class="badge-name">${badge.name}</div>
            ${isNew ? '<div class="badge-new">NEW!</div>' : ''}
          </div>
        `;
      }).join('');
      
      // Update stats
      const unlockedCount = Object.values(achievements).filter(a => a?.unlocked).length;
      document.getElementById('badgesEarned').textContent = unlockedCount;
      document.getElementById('totalRankings').textContent = stats.totalRankings;
      document.getElementById('completion').textContent = Math.round((unlockedCount / BADGES.length) * 100) + '%';
      
      // Update notification count on parent page
      updateNotificationCount();
    }
    
    // Show badge details modal
   function showBadgeDetails(badgeId) {
  const badge = BADGES.find(b => b.id === badgeId);
  const achievements = loadAchievements();
  const achievement = achievements[badgeId];
  const isUnlocked = achievement?.unlocked;
  
  document.getElementById('modalBadgeImage').src = isUnlocked ? badge.image : badge.silhouette;
  document.getElementById('modalBadgeName').textContent = badge.name;
  
  // Only show description and requirement if unlocked
  if (isUnlocked) {
    document.getElementById('modalBadgeDescription').textContent = badge.description;
    document.getElementById('modalBadgeRequirement').textContent = `Requirement: ${badge.requirement}`;
    
    const date = new Date(achievement.date);
    document.getElementById('modalBadgeDate').textContent = `Earned on ${date.toLocaleDateString()}`;
    
    // Mark as viewed
    if (achievement.isNew) {
      sessionStorage.setItem(`badge_${badgeId}_viewed`, 'true');
      achievement.isNew = false;
      saveAchievements(achievements);
      renderBadges();
    }
  } else {
    // Mystery text for locked badges
    document.getElementById('modalBadgeDescription').textContent = 'Keep playing to discover how to unlock this badge!';
    document.getElementById('modalBadgeRequirement').textContent = '???';
    document.getElementById('modalBadgeDate').textContent = 'Not yet earned';
  }
  
  document.getElementById('badgeModal').style.display = 'flex';
}
    
    // Close badge modal
    function closeBadgeModal() {
      document.getElementById('badgeModal').style.display = 'none';
    }
    
    // Update notification count
    function updateNotificationCount() {
      const achievements = loadAchievements();
      const newCount = Object.values(achievements).filter(a => 
        a?.isNew && !sessionStorage.getItem(`badge_${Object.keys(achievements).find(k => achievements[k] === a)}_viewed`)
      ).length;
      
      // Store for the main page to read
      sessionStorage.setItem('newBadgeCount', newCount);
    }
    
    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
  validateExistingBadges(); // Fix any incorrectly awarded badges
  checkAchievements();
  renderBadges();
});
    
    // Close modal on outside click
    document.getElementById('badgeModal').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) closeBadgeModal();
    });
  </script>
  <script src="js/auth.js"></script>
  <script src="js/sync.js"></script>
<script>
// User Header Handler
(function() {
  const userHeader = document.getElementById('userHeader');
  const headerSprite = document.getElementById('headerSprite');
  const headerUsername = document.getElementById('headerUsername');
  const btnLogout = document.getElementById('btnLogout');
  
  async function updateUserHeader() {
    const user = window.PokeRankrAuth.getCurrentUser();
    
    if (!user) {
      userHeader.style.display = 'none';
      return;
    }
    
    const { data: profile } = await window.PokeRankrAuth.supabase
      .from('user_profiles')
      .select('username, sprite_id, sprite_shiny')
      .eq('user_id', user.id)
      .maybeSingle();
    
    if (profile) {
      const spriteUrl = profile.sprite_shiny
        ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/shiny/${profile.sprite_id}.png`
        : `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${profile.sprite_id}.png`;
      
      headerSprite.src = spriteUrl;
      headerUsername.textContent = profile.username;
      userHeader.style.display = 'block';
    }
  }
  
  btnLogout?.addEventListener('click', async () => {
    if (confirm('Are you sure you want to log out?')) {
      await window.PokeRankrAuth.signOut();
      localStorage.removeItem('PR_PLAY_MODE');
      window.location.href = 'index.html';
    }
  });
  
  window.PokeRankrAuth.onAuthChange((user) => {
    updateUserHeader();
  });
  
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(updateUserHeader, 200);
  });
})();
</script>
</body>
</html>